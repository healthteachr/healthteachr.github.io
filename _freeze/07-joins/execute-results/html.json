{
  "hash": "1b8c1364bfe06f679bc9662dad903f18",
  "result": {
    "engine": "knitr",
    "markdown": "::: {.cell layout-align=\"center\"}\n\n:::\n\n\n# Data Relations {#sec-joins}\n\n## Intended Learning Outcomes {#sec-ilo-joins .unnumbered}\n\n-   Be able to match related data across multiple tables\n-   Be able to combine data from multiple files\n\n## Walkthrough video {#sec-walkthrough-joins .unnumbered}\n\nThere is a walkthrough video of this chapter available via [Echo360.](https://echo360.org.uk/media/519bb538-58b3-4710-85df-d71c56001a5d/public) Please note that there may have been minor edits to the book since the video was recorded. Where there are differences, the book should always take precedence.\n\n## Set-up {#sec-setup-joins}\n\nFirst, create a new project for the work we'll do in this chapter named <code class='path'>07-relations</code>. Second, open and save a new R Markdown document named `relations.Rmd`, delete the welcome text, and load the required packages for this chapter.\n\n\n::: {.cell layout-align=\"center\" verbatim='r setup, include=FALSE'}\n<div class='verbatim'><pre class='sourceCode r'><code class='sourceCode R'>&#96;&#96;&#96;{r setup, include=FALSE}</code></pre>\n\n```{.r .cell-code}\nlibrary(tidyverse)     # includes readr & tibble\n```\n\n<pre class='sourceCode r'><code class='sourceCode R'>&#96;&#96;&#96;</code></pre></div>\n:::\n\n\nDownload the [Data transformation cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf).\n\n## Loading data {#sec-joins-data}\n\nThe data you want to report on or visualise are often in more than one file (or more than one tab of an excel file or googlesheet). You might need to join up a table of participant information with a table of questionnaire scores, or combine the monthly athletic performance reports across several months.\n\nFor this demo, rather than loading in data, we'll create two small data tables from scratch using the `tibble()` function.\n\n`participants` has id, city and postcode for five participants 1-5.\n\n-   `1:5` will fill the variable `id` with all integers between 1 and 5.\n-   `city` and `postcode` both use the `c()` function to enter multiple strings. Note that each entry is contained within its own quotation marks, apart from missing data, which is recorded as `NA`.\n-   When entering data like this, it's important that the order of each variable matches up. So number 1 will correspond to \"Bristol\" and \"BS1 1NE\".\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nparticipants <- tibble(\n  id = 1:5,\n  city = c(\"Bristol\", \"Gloucester\", NA, \"Exeter\", \"Plymouth\"),\n  postcode = c(\"BS1 1NE\", \"GL1 1HX\", NA, \"EX1 2EA\", \"PL1 1DA\")\n)\n```\n:::\n\n\n\n\nTable: Demo participants table.\n\n| id|city       |postcode |\n|--:|:----------|:--------|\n|  1|Bristol    |BS1 1NE  |\n|  2|Gloucester |GL1 1HX  |\n|  3|NA         |NA       |\n|  4|Exeter     |EX1 2EA  |\n|  5|Plymouth   |PL1 1DA  |\n\n\n\n`activity` has participant id and the activity types engaged in during the week (1=walking, 2=running etc.). Some participants from the previous table engaged in no physical activity during the week (so have no responses for activity type), some have more than one activity type, and some are not in the participant table.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nactivity <- tibble(\n  id = c(2, 3, 4, 4, 5, 5, 6, 6, 7),\n  type = c(1, 1, 14, 2, 9, 1, 1, 2, 3)\n)\n```\n:::\n\n\n\n\nTable: Demo activity table.\n\n| id| type|\n|--:|----:|\n|  2|    1|\n|  3|    1|\n|  4|   14|\n|  4|    2|\n|  5|    9|\n|  5|    1|\n|  6|    1|\n|  6|    2|\n|  7|    3|\n\n\n\n## Mutating Joins\n\n<a href='https://psyteachr.github.io/glossary/m#mutating-joins' target='_blank' class='glossary' title='Joins that act like the dplyr::mutate() function in that they add new columns to one table based on values in another table.'>Mutating joins</a> act like the `dplyr::mutate()` function in that they add new columns to one table based on values in another table. We'll learn more about the `mutate()` function in @sec-tidy.\n\nAll the mutating joins have this basic syntax:\n\n`****_join(x, y, by = NULL, suffix = c(\".x\", \".y\"))`\n\n-   `x` = the first (left) table\n-   `y` = the second (right) table\n-   `by` = what columns to match on. If you leave this blank, it will match on all columns with the same names in the two tables.\n-   `suffix` = if columns have the same name in the two tables, but you aren't joining by them, they get a suffix to make them unambiguous. This defaults to \".x\" and \".y\", but you can change it to something more meaningful.\n\n::: {.callout-note}\nYou can leave out the `by` argument if you're matching on all of the columns with the same name, but it's good practice to always specify it so your code is robust to changes in the loaded data.\n:::\n\n### left_join() {#sec-left_join}\n\n::: join\n<img src=\"images/joins/left_join.png\"/>\n:::\n\nA `left_join` keeps all the data from the first (left) table and adds anything that matches from the second (right) table. If the right table has more than one match for a row in the left table, there will be more than one row in the joined table (see ids 4 and 5).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nleft_data <- left_join(participants, activity, by = \"id\")\nleft_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode | type|\n|--:|:----------|:--------|----:|\n|  1|Bristol    |BS1 1NE  |   NA|\n|  2|Gloucester |GL1 1HX  |    1|\n|  3|NA         |NA       |    1|\n|  4|Exeter     |EX1 2EA  |   14|\n|  4|Exeter     |EX1 2EA  |    2|\n|  5|Plymouth   |PL1 1DA  |    9|\n|  5|Plymouth   |PL1 1DA  |    1|\n\n</div>\n:::\n:::\n\n\n::: join\n<img src=\"images/joins/left_join_rev.png\"/>\n:::\n\nThe order you specify the tables matters. In the below code we have reversed the order and so the result is all rows from the `activity` table joined to any matching rows from the `participants` table.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nleft2_data <- left_join(activity, participants, by = \"id\")\nleft2_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id| type|city       |postcode |\n|--:|----:|:----------|:--------|\n|  2|    1|Gloucester |GL1 1HX  |\n|  3|    1|NA         |NA       |\n|  4|   14|Exeter     |EX1 2EA  |\n|  4|    2|Exeter     |EX1 2EA  |\n|  5|    9|Plymouth   |PL1 1DA  |\n|  5|    1|Plymouth   |PL1 1DA  |\n|  6|    1|NA         |NA       |\n|  6|    2|NA         |NA       |\n|  7|    3|NA         |NA       |\n\n</div>\n:::\n:::\n\n\n### right_join() {#sec-right_join}\n\n::: join\n<img src=\"images/joins/right_join.png\"/>\n:::\n\nA `right_join` keeps all the data from the second (right) table and joins anything that matches from the first (left) table.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nright_data <- right_join(participants, activity, by = \"id\")\nright_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode | type|\n|--:|:----------|:--------|----:|\n|  2|Gloucester |GL1 1HX  |    1|\n|  3|NA         |NA       |    1|\n|  4|Exeter     |EX1 2EA  |   14|\n|  4|Exeter     |EX1 2EA  |    2|\n|  5|Plymouth   |PL1 1DA  |    9|\n|  5|Plymouth   |PL1 1DA  |    1|\n|  6|NA         |NA       |    1|\n|  6|NA         |NA       |    2|\n|  7|NA         |NA       |    3|\n\n</div>\n:::\n:::\n\n\n::: {.callout-note}\nThis table has the same information as `left_join(activity, participants, by = \"id\")`, but the columns are in a different order (left table, then right table).\n:::\n\n### inner_join() {#sec-inner_join}\n\n::: join\n<img src=\"images/joins/inner_join.png\"/>\n:::\n\nAn `inner_join` returns all the rows that have a match in both tables. Changing the order of the tables will change the order of the columns, but not which rows are kept.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninner_data <- inner_join(participants, activity, by = \"id\")\ninner_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode | type|\n|--:|:----------|:--------|----:|\n|  2|Gloucester |GL1 1HX  |    1|\n|  3|NA         |NA       |    1|\n|  4|Exeter     |EX1 2EA  |   14|\n|  4|Exeter     |EX1 2EA  |    2|\n|  5|Plymouth   |PL1 1DA  |    9|\n|  5|Plymouth   |PL1 1DA  |    1|\n\n</div>\n:::\n:::\n\n\n### full_join() {#sec-full_join}\n\n::: join\n<img src=\"images/joins/full_join.png\"/>\n:::\n\nA `full_join` lets you join up rows in two tables while keeping all of the information from both tables. If a row doesn't have a match in the other table, the other table's column values are set to `NA`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfull_data <- full_join(participants, activity, by = \"id\")\nfull_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode | type|\n|--:|:----------|:--------|----:|\n|  1|Bristol    |BS1 1NE  |   NA|\n|  2|Gloucester |GL1 1HX  |    1|\n|  3|NA         |NA       |    1|\n|  4|Exeter     |EX1 2EA  |   14|\n|  4|Exeter     |EX1 2EA  |    2|\n|  5|Plymouth   |PL1 1DA  |    9|\n|  5|Plymouth   |PL1 1DA  |    1|\n|  6|NA         |NA       |    1|\n|  6|NA         |NA       |    2|\n|  7|NA         |NA       |    3|\n\n</div>\n:::\n:::\n\n\n## Filtering Joins\n\n<a href='https://psyteachr.github.io/glossary/f#filtering-joins' target='_blank' class='glossary' title='Joins that act like the dplyr::filter() function in that they remove rows from the data in one table based on the values in another table.'>Filtering joins</a> act like the `dplyr::filter()` function in that they keep and remove rows from the data in one table based on the values in another table. The result of a filtering join will only contain rows from the left table and have the same number or fewer rows than the left table. We'll learn more about the `filter()` function in @sec-wrangle.\n\n### semi_join() {#sec-semi_join}\n\n::: join\n<img src=\"images/joins/semi_join.png\"/>\n:::\n\nA `semi_join` returns all rows from the left table where there are matching values in the right table, keeping just columns from the left table.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsemi_data <- semi_join(participants, activity, by = \"id\")\nsemi_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode |\n|--:|:----------|:--------|\n|  2|Gloucester |GL1 1HX  |\n|  3|NA         |NA       |\n|  4|Exeter     |EX1 2EA  |\n|  5|Plymouth   |PL1 1DA  |\n\n</div>\n:::\n:::\n\n\n::: {.callout-note}\nUnlike an inner join, a semi join will never duplicate the rows in the left table if there is more than one matching row in the right table.\n:::\n\n::: join\n<img src=\"images/joins/semi_join_rev.png\"/>\n:::\n\nOrder matters in a semi join.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsemi2_data <- semi_join(activity, participants, by = \"id\")\nsemi2_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id| type|\n|--:|----:|\n|  2|    1|\n|  3|    1|\n|  4|   14|\n|  4|    2|\n|  5|    9|\n|  5|    1|\n\n</div>\n:::\n:::\n\n\n### anti_join() {#sec-anti_join}\n\n::: join\n<img src=\"images/joins/anti_join.png\"/>\n:::\n\nAn `anti_join` return all rows from the left table where there are *not* matching values in the right table, keeping just columns from the left table.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nanti_data <- anti_join(participants, activity, by = \"id\")\nanti_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city    |postcode |\n|--:|:-------|:--------|\n|  1|Bristol |BS1 1NE  |\n\n</div>\n:::\n:::\n\n\n::: join\n<img src=\"images/joins/anti_join_rev.png\"/>\n:::\n\nOrder matters in an anti join.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nanti2_data <- anti_join(activity, participants, by = \"id\")\nanti2_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id| type|\n|--:|----:|\n|  6|    1|\n|  6|    2|\n|  7|    3|\n\n</div>\n:::\n:::\n\n\n## Multiple joins\n\nThe `****_join()` functions are all **two-table verbs**, that is, you can only join together two tables at a time. However, you may often need to join together multiple tables. To do so, you simply need to add on additional joins. You can do this by creating an intermediate object or more efficiently by using a pipe.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# create a table of overall satisfaction with life scores\nsatisfaction <- tibble(\n  id = 1:5,\n  satisfaction = c(4, 3, 2, 3, 1)\n)\n\n# perform the initial join\njoin_1 <- left_join(participants, activity, by = \"id\")\n\n# perform the second join on the new object\njoin_2 <- left_join(join_1, satisfaction, \n                    by = \"id\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# more efficient method using the pipe\npipe_join <- participants %>%\n  left_join(activity, by = \"id\") %>%\n  left_join(satisfaction, by = \"id\")\n```\n:::\n\n\n::: {.callout-warning}\nAt every stage of any analysis you should **check your output** to ensure that what you created is what you intended to create, but this is particularly true of joins. You should be familiar enough with your data through routine checks using functions like `glimpse()`, `str()`, and `summary()` to have a rough idea of what the join should result in. At the very least, you should know whether the joined object should result in more or fewer variables and observations.\n\nIf you have a multi-line join like in the above piped example, build up the code and check the output at each stage.\n:::\n\n\n## Binding Joins\n\n<a href='https://psyteachr.github.io/glossary/b#binding-joins' target='_blank' class='glossary' title='Joins that bind one table to another by adding their rows or columns together.'>Binding joins</a> bind one table to another by adding their rows or columns together.\n\n### bind_rows() {#sec-bind_rows}\n\nYou can combine the rows of two tables with `bind_rows`.\n\nHere we'll add participant data for participants 6-9 and bind that to the original participant table.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_participants <- tibble(\n  id = 6:9,\n  city = c(\"Gloucester\", \"Bath\", \"Bristol\", \"Bristol\"),\n  postcode = c(\"GL1 1BZ\", \"BA1 1TS\", \"BS1 3BF\", \"BS1 2PZ\")\n)\n\nbindr_data <- bind_rows(participants, new_participants)\nbindr_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode |\n|--:|:----------|:--------|\n|  1|Bristol    |BS1 1NE  |\n|  2|Gloucester |GL1 1HX  |\n|  3|NA         |NA       |\n|  4|Exeter     |EX1 2EA  |\n|  5|Plymouth   |PL1 1DA  |\n|  6|Gloucester |GL1 1BZ  |\n|  7|Bath       |BA1 1TS  |\n|  8|Bristol    |BS1 3BF  |\n|  9|Bristol    |BS1 2PZ  |\n\n</div>\n:::\n:::\n\n\nThe columns just have to have the same names, they don't have to be in the same order. Any columns that differ between the two tables will just have `NA` values for entries from the other table.\n\nIf a row is duplicated between the two tables (like id 5 below), the row will also be duplicated in the resulting table. If your tables have the exact same columns, you can use `union()` (see @sec-union) to avoid duplicates.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_participants <- tibble(\n  id = 5:9,\n  postcode = c(\"PL1 1DA\", \"GL1 1BZ\", \"BA1 1TS\", \"BS1 3BF\", \"BS1 2PZ\"),\n  city = c(\"Plymouth\", \"Gloucester\", \"Bath\", \"Bristol\", \"Bristol\"),\n  new = c(1,2,3,4,5)\n)\n\nbindr2_data <- bind_rows(participants, new_participants)\nbindr2_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode | new|\n|--:|:----------|:--------|---:|\n|  1|Bristol    |BS1 1NE  |  NA|\n|  2|Gloucester |GL1 1HX  |  NA|\n|  3|NA         |NA       |  NA|\n|  4|Exeter     |EX1 2EA  |  NA|\n|  5|Plymouth   |PL1 1DA  |  NA|\n|  5|Plymouth   |PL1 1DA  |   1|\n|  6|Gloucester |GL1 1BZ  |   2|\n|  7|Bath       |BA1 1TS  |   3|\n|  8|Bristol    |BS1 3BF  |   4|\n|  9|Bristol    |BS1 2PZ  |   5|\n\n</div>\n:::\n:::\n\n\n### bind_cols() {#sec-bind_cols}\n\nYou can merge two tables with the same number of rows using `bind_cols`. This is only useful if the two tables have the same number of rows in the exact same order.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_info <- tibble(\n  dominant_hand = c(\"right\", \"left\", \"right\", \"right\", \"left\")\n)\n\nbindc_data <- bind_cols(participants, new_info)\nbindc_data \n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode |dominant_hand |\n|--:|:----------|:--------|:-------------|\n|  1|Bristol    |BS1 1NE  |right         |\n|  2|Gloucester |GL1 1HX  |left          |\n|  3|NA         |NA       |right         |\n|  4|Exeter     |EX1 2EA  |right         |\n|  5|Plymouth   |PL1 1DA  |left          |\n\n</div>\n:::\n:::\n\n\n::: {.callout-note}\nThe only advantage of `bind_cols()` over a mutating join is when the tables don't have any IDs to join by and you have to rely solely on their order. Otherwise, you should use a mutating join (all four mutating joins result in the same output when all rows in each table have exactly one match in the other table).\n:::\n\n### Importing multiple files\n\nIf you need to import and bind a whole folder full of files that have the same structure, get a list of all the files you want to combine. It's easiest if they're all in the same directory, although you can use a pattern to select the files you want if they have a systematic naming structure.\n\nFirst, save the two participant tables to CSV files. The `dir.create()` function makes a folder called \"data\". The `showWarnings = FALSE` argument means that you won't get a warning if the folder already exists, it just won't do anything.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# write our data to a new folder for the demo\ndir.create(\"data\", showWarnings = FALSE)\nwrite_csv(x = participants, file = \"data/participants1.csv\")\nwrite_csv(x = new_participants, file = \"data/participants2.csv\")\n```\n:::\n\n\nNext, retrieve a list of all file names in the data folder that contain the string \"participants\"\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfiles <- list.files(\n  path = \"data\", \n  pattern = \"participants\", \n  full.names = TRUE\n)\n\nfiles\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data/participants1.csv\" \"data/participants2.csv\"\n```\n\n\n:::\n:::\n\n\nNext, we'll iterate over this list to read in the data from each file. Whilst this won't be something we cover in detail in the core resources of this course, <a href='https://psyteachr.github.io/glossary/i#iteration' target='_blank' class='glossary' title='Repeating a process or function'>iteration</a> is an important concept to know about. Iteration is where you perform the same task on multiple different inputs. As a general rule of thumb, if you find yourself copying and pasting the same thing more than twice, there's a more efficient and less error-prone way to do it, although these functions do typically require a stronger grasp of programming.\n\nThe <pkg>purrr</pkg> package contains functions to help with iteration. `purrr::map_df()` maps a function to a list and returns a data frame (table) of the results.\n\n* `.x` is the list of file paths \n* `.f` specifies the function to map to each of those file paths.\n* The resulting object `all_files` will be a data frame that combines all the files together, similar to if you had imported them separately and then used `bind_rows()`. Note that `map_df()` will only work in this way if the structure of all files is identical.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nall_files <- purrr::map_df(.x = files, .f = read_csv)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n## Set Operations\n\n<a href='https://psyteachr.github.io/glossary/s#set-operations' target='_blank' class='glossary' title='Functions that compare two tables and return rows that match (intersect), are in either table (union), or are in one table but not the other (setdiff).'>Set operations</a> compare two tables and return rows that match (intersect), are in either table (union), or are in one table but not the other (setdiff).\n\n### intersect() {#sec-intersect}\n\n`dplyr::intersect()` returns all rows in two tables that match exactly. The columns don't have to be in the same order, but they have to have the same names.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_participants <- tibble(\n  id = 5:9,\n  postcode = c(\"PL1 1DA\", \"GL1 1BZ\", \"BA1 1TS\", \"BS1 3BF\", \"BS1 2PZ\"),\n  city = c(\"Plymouth\", \"Gloucester\", \"Bath\", \"Bristol\", \"Bristol\")\n)\n\nintersect_data <- intersect(participants, new_participants)\nintersect_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city     |postcode |\n|--:|:--------|:--------|\n|  5|Plymouth |PL1 1DA  |\n\n</div>\n:::\n:::\n\n\n::: {.callout-warning}\nIf you've forgotten to load dplyr or the tidyverse, <a href='https://psyteachr.github.io/glossary/b#base-r' target='_blank' class='glossary' title='The set of R functions that come with a basic installation of R, before you add external packages.'>base R</a> also has a `base::intersect()` function that doesn't work like `dplyr::intersect()`. The error message can be confusing and looks something like this:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbase::intersect(participants, new_participants)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist()\n```\n\n\n:::\n:::\n\n:::\n\n### union() {#sec-union}\n\n`dplyr::union()` returns all the rows from both tables, removing duplicate rows, unlike `bind_rows()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nunion_data <- union(participants, new_participants)\nunion_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode |\n|--:|:----------|:--------|\n|  1|Bristol    |BS1 1NE  |\n|  2|Gloucester |GL1 1HX  |\n|  3|NA         |NA       |\n|  4|Exeter     |EX1 2EA  |\n|  5|Plymouth   |PL1 1DA  |\n|  6|Gloucester |GL1 1BZ  |\n|  7|Bath       |BA1 1TS  |\n|  8|Bristol    |BS1 3BF  |\n|  9|Bristol    |BS1 2PZ  |\n\n</div>\n:::\n:::\n\n\n::: {.callout-warning}\nIf you've forgotten to load dplyr or the tidyverse, <a href='https://psyteachr.github.io/glossary/b#base-r' target='_blank' class='glossary' title='The set of R functions that come with a basic installation of R, before you add external packages.'>base R</a> also has a `base::union()` function. You usually won't get an error message, but the output won't be what you expect.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbase::union(participants, new_participants)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"Bristol\"    \"Gloucester\" NA           \"Exeter\"     \"Plymouth\"  \n\n[[3]]\n[1] \"BS1 1NE\" \"GL1 1HX\" NA        \"EX1 2EA\" \"PL1 1DA\"\n\n[[4]]\n[1] 5 6 7 8 9\n\n[[5]]\n[1] \"PL1 1DA\" \"GL1 1BZ\" \"BA1 1TS\" \"BS1 3BF\" \"BS1 2PZ\"\n\n[[6]]\n[1] \"Plymouth\"   \"Gloucester\" \"Bath\"       \"Bristol\"    \"Bristol\"   \n```\n\n\n:::\n:::\n\n:::\n\n### setdiff() {#sec-setdiff}\n\n`dplyr::setdiff` returns rows that are in the first table, but not in the second table.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetdiff_data <- setdiff(participants, new_participants)\nsetdiff_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode |\n|--:|:----------|:--------|\n|  1|Bristol    |BS1 1NE  |\n|  2|Gloucester |GL1 1HX  |\n|  3|NA         |NA       |\n|  4|Exeter     |EX1 2EA  |\n\n</div>\n:::\n:::\n\n\nOrder matters for `setdiff`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetdiff2_data <- setdiff(new_participants, participants)\nsetdiff2_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|postcode |city       |\n|--:|:--------|:----------|\n|  6|GL1 1BZ  |Gloucester |\n|  7|BA1 1TS  |Bath       |\n|  8|BS1 3BF  |Bristol    |\n|  9|BS1 2PZ  |Bristol    |\n\n</div>\n:::\n:::\n\n\n::: {.callout-warning}\nIf you've forgotten to load dplyr or the tidyverse, <a href='https://psyteachr.github.io/glossary/b#base-r' target='_blank' class='glossary' title='The set of R functions that come with a basic installation of R, before you add external packages.'>base R</a> also has a `base::setdiff()` function. You usually won't get an error message, but the output might not be what you expect because `base::setdiff()` expects columns to be in the same order, so id 5 here registers as different between the two tables.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbase::setdiff(participants, new_participants)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$id\n[1] 1 2 3 4 5\n\n$city\n[1] \"Bristol\"    \"Gloucester\" NA           \"Exeter\"     \"Plymouth\"  \n\n$postcode\n[1] \"BS1 1NE\" \"GL1 1HX\" NA        \"EX1 2EA\" \"PL1 1DA\"\n```\n\n\n:::\n:::\n\n:::\n\n## Conflicting variable types\n\nAs we covered in @sec-data, when you import or create data, R will do its best to set each column to an appropriate data type. However, sometimes it gets it wrong or sometimes there's something in the way the data has been encoded in the original spreadsheet that causes the data type to be different than expected. When joining datasets by common columns, it's important that not only are the variable names identical, but the data type of those variables is identical.\n\nLet's recreate our `new_participants` dataset but this time, we'll specify that `id` is a <a href='https://psyteachr.github.io/glossary/c#character' target='_blank' class='glossary' title='A data type representing strings of text.'>character</a> variable.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_participants2 <- tibble(\n  id = as.character(5:9),\n  postcode = c(\"PL1 1DA\", \"GL1 1BZ\", \"BA1 1TS\", \"BS1 3BF\", \"BS1 2PZ\"),\n  city = c(\"Plymouth\", \"Gloucester\", \"Bath\", \"Bristol\", \"Bristol\")\n)\nstr(new_participants2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [5 × 3] (S3: tbl_df/tbl/data.frame)\n $ id      : chr [1:5] \"5\" \"6\" \"7\" \"8\" ...\n $ postcode: chr [1:5] \"PL1 1DA\" \"GL1 1BZ\" \"BA1 1TS\" \"BS1 3BF\" ...\n $ city    : chr [1:5] \"Plymouth\" \"Gloucester\" \"Bath\" \"Bristol\" ...\n```\n\n\n:::\n:::\n\n\nIf you try to join this dataset to any of the other datasets where `id` is stored as a <a href='https://psyteachr.github.io/glossary/n#numeric' target='_blank' class='glossary' title='A data type representing a real decimal number or integer.'>numeric</a> variable, it will produce an error. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninner_join(participants, new_participants2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(id, city, postcode)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `inner_join()`:\n! Can't join `x$id` with `y$id` due to incompatible types.\nℹ `x$id` is a <integer>.\nℹ `y$id` is a <character>.\n```\n\n\n:::\n:::\n\n\nThe same goes for `bind_rows()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbind_rows(participants, new_participants2)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `bind_rows()`:\n! Can't combine `..1$id` <integer> and `..2$id` <character>.\n```\n\n\n:::\n:::\n\n\n\nAn alternative method to change variable types from what we showed you in @sec-data is to use the `as.***` functions. If you type `as.` into a code chunk, you will see that there are a huge number of these functions for transforming variables and datasets to different types. Exactly which one you need will depend on the data you have, but a few commonly used ones are:\n\n* `as.numeric()` - convert a variable to <a href='https://psyteachr.github.io/glossary/n#numeric' target='_blank' class='glossary' title='A data type representing a real decimal number or integer.'>numeric</a>. Useful for when you have a variable of real numbers that have been encoded as character. Any values that can't be turned into numbers (e.g., if you have the word \"missing\" in cells that you have no data for), will be returned as `NA`.\n* `as.factor()` - convert a variable to a <a href='https://psyteachr.github.io/glossary/f#factor' target='_blank' class='glossary' title='A data type where a specific set of values are stored with labels; An explanatory variable manipulated by the experimenter'>factor</a>. You can set the factor levels and labels manually, or use the default order (alphabetical).\n* `as.character()` - convert a variable to <a href='https://psyteachr.github.io/glossary/c#character' target='_blank' class='glossary' title='A data type representing strings of text.'>character</a> data.\n* `as.tibble()` and `as.data.frame()` - convert a list object (not a variable) to a tibble or a data frame (two different table formats). This isn't actually relevant to what we're discussing here, but it's a useful one to be aware of because sometimes you'll run into issues where you get an error that specifically requests your data is a tibble or data frame type and you can use this function to overwrite your object. \n\nTo use these functions on a variable we can use `mutate()` to overwrite the variable with that variable as the new data type:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_participants2 <- new_participants2 %>%\n  mutate(id = as.numeric(id))\n```\n:::\n\n\nOnce you've done this, the joins will now work:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninner_join(activity, new_participants2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(id)`\n```\n\n\n:::\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id| type|postcode |city       |\n|--:|----:|:--------|:----------|\n|  5|    9|PL1 1DA  |Plymouth   |\n|  5|    1|PL1 1DA  |Plymouth   |\n|  6|    1|GL1 1BZ  |Gloucester |\n|  6|    2|GL1 1BZ  |Gloucester |\n|  7|    3|BA1 1TS  |Bath       |\n\n</div>\n:::\n:::\n\n\n\n## Exercises\n\nThere's lots of different use cases for the `****_join()` functions. These exercises will allow you to practice different joins. If you have any examples of where joins might be helpful in your own work, please post them on Teams in the week 6 channel, as having many concrete examples can help distinguish between the different joins.\n\n### Grade data\n\nA Scottish University's grading scheme uses a 22-point alphanumeric scale. Each alphanumeric grade (e.g., B2) has an underlying numeric Grade Point (e.g., 16). \n\nWe have been charged with organising these data. To do this, we need to be able to go between the two forms of grade data. We need the numeric form in order to be able to calculate descriptive statistics about the mean grade, but we need the alphanumeric form to release to student records.\n\n* Download <a href=\"data/grade_data1.csv\" download>grade_data1.csv</a>, <a href=\"data/grade_data2.csv\" download>grade_data2.csv</a> and <a href=\"data/mark_scheme.csv\" download>mark_scheme.csv</a> into your data folder.\n\n* Read in `mark_scheme.csv` and save it to an object named `scheme`.\n* Read in `grade_data1.csv` and save it to an object named `grades1`.\n* Read in `grade_data2.csv` and save it to an object named `grades2`.\n\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\nscheme <- read_csv(\"data/mark_scheme.csv\")\ngrades1 <- read_csv(\"data/grade_data1.csv\") \ngrades2 <- read_csv(\"data/grade_data2.csv\")\n```\n\n:::\n:::\n\n\n\n### Matching the variable types\n\nAt this University, all students are given a numeric ID number. However, that ID number is also then combined with the first letter of a student's surname to create the username that is used with their email address. For example, if a student's ID is 1234567 and their surname is Malkowski, their username would be 1234567m. From a data wrangling perspective, this is very annoying because the numeric ID will be stored as numeric data, but the username will be stored as character because of the letter at the end. `grades1` has a numeric id whilst `grades2` has the additional letter. In order to join these datasets, we need to standardise the variables.\n\nFirst, remove the letter character from `id` using the function `stringr::str_replace_all()`, which replaces text that matches a pattern. Here, we're using the pattern `\"[a-z]\"`, which matches all lowercase letters a through z, and replacing them with `\"\"`. See the help for `?about_search_regex` for more info about how to set patterns (these can get really complex).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngrades1 <- grades1 %>%\n  mutate(id = str_replace_all(\n    id, # the variable you want to search\n    pattern = \"[a-z]\", # find all letters a-z\n    replacement = \"\" # replace with nothing\n  ))  \n```\n:::\n\n\n\nNow, transform the data type of `id` so that it matches the data type in `grades2`.\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\n# check variable types\nglimpse(grades1)\nglimpse(grades2) \n\ngrades1 <- grades1 %>%\n  mutate(id = as.numeric(id))\n```\n\n:::\n:::\n\n\n\n### Complete records\n\nIn this example, we want to join the grade data to the marking scheme so that each student with a grade has both the grade and the grade point. But we also want a complete record of all students on the course, so students with missing grades should still be included in the data.\n\n* Join `grades1` and `scheme` and store this table in an object named `exam_all`.\n* Do the same for `grades2` and save it in `essay_all`.\n* Both `exam_all` and `essay_all` should have 100 observations of 4 variables.\n\n\n<div class='webex-solution'><button>Hint</button>\n\n\nYou want to keep all of the data from `grade_data1` and `grade_data2`, but you only want the alphanumeric grades from `scheme` for the Grade Point values that exist in `grades`. E.g., if no-one was awarded an F1, your final dataset shouldn't have that in it.\n\n\n</div>\n\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\nexam_all <- left_join(grades1, scheme, by = \"Points\")\nessay_all <- left_join(grades2, scheme, by = \"Points\")\n```\n\n:::\n:::\n\n\n\n### Missing data\n\nAlternatively, you may wish to have a dataset that only contains data for students who submitted each assessment and have a grade. First, run `summary()` on both `exam_all` and `essay_all`. \n\n* How many exam grades are missing? <input class='webex-solveme nospaces' size='2' data-answer='[\"17\"]'/>\n* How many essay grades are missing? <input class='webex-solveme nospaces' size='2' data-answer='[\"23\"]'/>\n\nNow, create an object `exam_grades` that joins together `grades1` and `scheme`, but this time the resulting object should only contain data from students who have a grade. Do the same but for `grades2` and store it in `essay_grades`.\n\nBefore you do this, given what you know about how many data points are missing in each data set:\n\n* How many observations should `exam_grades` have? <input class='webex-solveme nospaces' size='2' data-answer='[\"83\"]'/>\n* How many observations should `essay_grades` have? <input class='webex-solveme nospaces' size='2' data-answer='[\"77\"]'/>\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\nexam_grades <- inner_join(grades1, scheme, by = \"Points\")\nessay_grades <- inner_join(grades2, scheme, by = \"Points\")\n```\n\n:::\n:::\n\n\n\n<div class='webex-solution'><button>Alternative solution</button>\n\n\nIt's worth noting that in reality you wouldn't actually go back to the raw data and do another join to get this dataset, you could just remove all the missing responses by adding `%>% drop_na()` to `exam_all` and `essay_all`. However, for the purposes of teaching joins, we'll do it this slightly artificial way.\n\n\n</div>\n\n\nNow, create a dataset `completes` that joins the grades for students who have a grade for **both** the essay and the exam.  \n\n* Because both `exam_grades` and `essay_grades` have the variables `Assessment`, `Points` and `Grades` that are named the same, but have different data, you should amend the suffix so that the resulting variables are named `Points_exam` and `Points_essay` etc. You may need to consult the help documentation to see an example to figure this out. \n* Clean up the file with `select()` and only keep the variables `id`, `Grade_exam`, and `Grade_essay`.\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\ncompletes <- inner_join(exam_grades, essay_grades, \n                        by = \"id\", \n                        suffix = c(\"_exam\", \"_essay\")) %>%\n  select(id, Grade_exam, Grade_essay)\n```\n\n:::\n:::\n\n\n* How many students have a grade for both the exam and the essay? <input class='webex-solveme nospaces' size='2' data-answer='[\"62\"]'/>\n\nNow create a dataset `no_essay` that contains students that have a grade for the exam, but not the essay.\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\nno_essay <- anti_join(exam_grades, essay_grades, by = \"id\")\n```\n\n:::\n:::\n\n\n-   How many students have a grade for the exam but not the essay? <input class='webex-solveme nospaces' size='2' data-answer='[\"21\"]'/>\n\n\nFinally, now make a dataset `no_exam` that contains students who have a grade for the essay but not the exam.\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\nno_exam <- anti_join(essay_grades, exam_grades, by = \"id\")\n```\n\n:::\n:::\n\n\n-   How many students have a grade for the exam but not the essay? <input class='webex-solveme nospaces' size='2' data-answer='[\"15\"]'/>\n\n\n## Glossary {#sec-glossary-joins}\n\n\n::: {.cell layout-align=\"center\"}\n\n|term            |definition                                                                                                                                              |\n|:---------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------|\n|base R          |The set of R functions that come with a basic installation of R, before you add external packages.                                                      |\n|Binding joins   |Joins that bind one table to another by adding their rows or columns together.                                                                          |\n|character       |A data type representing strings of text.                                                                                                               |\n|factor          |A data type where a specific set of values are stored with labels; An explanatory variable manipulated by the experimenter                              |\n|Filtering joins |Joins that act like the dplyr::filter() function in that they remove rows from the data in one table based on the values in another table.              |\n|iteration       |Repeating a process or function                                                                                                                         |\n|Mutating joins  |Joins that act like the dplyr::mutate() function in that they add new columns to one table based on values in another table.                            |\n|numeric         |A data type representing a real decimal number or integer.                                                                                              |\n|Set operations  |Functions that compare two tables and return rows that match (intersect), are in either table (union), or are in one table but not the other (setdiff). |\n:::\n\n\n## Further resources {#sec-resources-joins}\n\n* [Data transformation cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf)\n* [Chapter 13: Relational Data](http://r4ds.had.co.nz/relational-data.html) in *R for Data Science*\n* [Chapter 21: Iteration](https://r4ds.had.co.nz/iteration.html) in *R for Data Science*.\n* [purrr cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/purrr.pdf)\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}