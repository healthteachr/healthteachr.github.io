# Data Visualisation {#sec-viz}

## Intended Learning Outcomes {#sec-ilo-viz .unnumbered}

* Be able to identify categorical versus continuous data
* Be able to create plots in layers using ggplot
* Be able to choose appropriate plots for data

## Walkthrough video {#sec-walkthrough-viz .unnumbered}

There is a walkthrough video of this chapter available via [Echo360](https://echo360.org.uk/media/457312c7-ae4f-4506-8016-a29df4f47462/public). Please note that there may have been minor edits to the book since the video was recorded. Where there are differences, the book should always take precedence.

## Set-up {#sec-setup-viz}

Create a new project for the work we'll do in this chapter:

-   <if>File > New Project...</if>
-   Name the project `r path("03-visualisation")`
-   Save it inside your ADS directory (**not** inside another project)

Then, create and save a new `r glossary("R Markdown")` document named `plots.Rmd`, get rid of the default template text, and load the packages in the set-up code `r glossary("chunk")`. You should have all of these packages installed already, but if you get the message `Error in library(x) : there is no package called ‘x’`, please refer to @sec-install-package.

```{r setup-viz, message=FALSE, verbatim="r setup, include=FALSE"}
library(tidyverse) # includes ggplot2
library(patchwork) # for multi-part plots
library(ggthemes)  # for plot themes
library(lubridate) # for manipulating dates
```

We'd recommend making a new code chunk for each different activity, and using the white space to make notes on any errors you make, things you find interesting, or questions you'd like to ask the course team.

Download the [ggplot2 cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf).

## Variable types

If a spreadsheet is in a `r glossary("tidy data")` format, each row is an `r glossary("observation")`, each column is a `r glossary("variable")`, and the information in each cell is a single `r glossary("value")`. We'll learn more about how to get our data into this format in @sec-tidy, but to get started we'll use datasets with the right format.

For example, the table below lists patients who have recently participated in a rehabilitation programme. Each row is an observation of one patient. There are 6 variables for each patient, their `surname`, `firstname`, `sex`, `birthdate`, `weight` (in kg), and `generalhealth` rating (on a 5-point scale from "very poor" to "very good").

```{r, echo = FALSE}
patients <- tribble(
  ~surname,   ~firstname,  ~sex,      ~birthdate,   ~weight, ~generalhealth,
  "Smith",    "Katie",     "female",  "1963-04-02",  71.2,    "poor",
  "Wang",     "Wei",       "female",  NA          ,  62.9,    "very good",
  "González", "Rafael",    "male",    "1946-10-01",  80.5,    "fair",
  "Johnson",  "Victor",    "male",    "1981-06-19",  65.0,    "very good"
) %>%
  mutate(sex = factor(sex, c("female", "male")),
         birthdate = as.Date(birthdate),
         generalhealth = factor(generalhealth, c("very poor", 
                                                 "poor", 
                                                 "fair",
                                                 "good", 
                                                 "very good")))

patients
```

Variables can be classified as `r glossary("continuous")` (numbers) or `r glossary("categorical")` (labels). When you're plotting data, it's important to know what kind of variables you have, which can help you decide what types of plots are most appropriate. Each variable also has a `r glossary("data type")`, such as `r glossary("numeric")` (numbers), `r glossary("character")` (text), or `r glossary("logical")` (TRUE/FALSE values). Some plots can only work on some data types. Make sure you have watched the mini-lecture on types of data from last week before you work through this chapter. Additionally, @sec-data-types has more details, as this concept will be relevant repeatedly.

```{r excel-format-cells, echo = FALSE, fig.cap="Data types are like the categories when you format cells in Excel."}
include_graphics("images/appx/excel-format-cells.png")
```

### Continuous

`r glossary("Continuous")` variables are properties you can measure, like weight. You can use continuous variables in mathematical operations, like calculating the sum total of a column of distances (metres) walked or the average number of goals per football match. They may be rounded to the nearest whole number, but it should make sense to have a measurement halfway between.

Continuous variables always have a `r glossary("numeric")` data type. They are either `r glossary("integer", "integers")` like `42` or `r glossary("double", "doubles")` like `3.14159`. 

### Categorical

`r glossary("Categorical")` variables are properties you can count, like blood group. Categorical variables can be `r glossary("nominal")`, where the categories don't really have an order, like blood group O, A, B, and AB, or `r glossary("ordinal")`, where they have a clear order but the distance between the categories isn't something you could exactly equate, like points on a `r glossary("Likert")` rating scale. Even if a data table uses numbers like 1-7 to represent ordinal variables, you shouldn't treat them like continuous variables.

Categorical data can have a `r glossary("character")` data type, also called `r glossary("string", "strings")`. These are made by putting text inside of quotes. That text can be letters, punctuation, or even numbers. For example, `"January"` is a character string, but so is `"1"` if you put it in quotes. The character data type is best for variables that can have a lot of different values that you can't predict ahead of time.

Categorical data can also be `r glossary("factor", "factors")`, a specific type of integer that lets you specify the category names and their order. This is useful for making plots display with categories in the order you want (otherwise they default to alphabetical order). The factor data type is best for categories that have a specific number of levels.

::: {.callout-caution}
## Do not factor numbers

If you factor numeric data, it gets converted to the integers 1 to the number of unique values, no matter what the values are. Additionally, you can no longer use the values as numbers, such as calculating the mean.

```{r, warning=TRUE, filename="Example"}
x <- c(-3, 0, .5)  # numeric vector
f <- factor(x)     # convert to factor
x == as.numeric(f) # does not convert back to numeric 
```

```{r, warning=TRUE, filename="You cannot average a factor"}
m <- mean(f)
```

:::

Sometimes people represent categorical variables with numbers that correspond to names, like 0 = "no" and 1 = "yes", but values in between don't have a clear interpretation. If you have control over how the data are recorded, it's better to use the character names for clarity. You'll learn how to recode columns in @sec-wrangle.

### Dates and times

Dates and times are a special case of variable. They can act like categorical or continuous variables, and there are special ways to plot them. Dates and times can be hard to work with, but the [<pkg>lubridate</pkg>(https://lubridate.tidyverse.org/) package provides functions to help you with this.

```{r}
# the current date
lubridate::today()
```

```{r}
# the current date and time in the GMT timezone
lubridate::now(tzone = "GMT")
```

::: {.callout-note .try}
## Test your understanding

Coming back to the patients dataset, what type of variable is in each column? You can use the function `glimpse()` to show a list of the column names, their data types, and the first few values in each column - here is the output of running `glimpse()` on the patients dataset.

```{r}
glimpse(patients)
```


```{r, include = FALSE}
num <- c(answer = "numeric", x = "character", x = "factor", x = "date")
chr <- c(x = "numeric", answer = "character", x = "factor",  x = "date")
fctr <- c(x = "numeric", x = "character", answer = "factor", x = "date")
date <- c(x = "numeric", x = "character", x = "factor", answer = "date")

cont <- c(answer = "continuous", x = "nominal", x = "ordinal", x = "date")
nom <- c(x = "continuous", answer = "nominal", x = "ordinal", x = "date")
ord <- c(x = "continuous", x = "nominal", answer = "ordinal", x = "date")
date <- c(x = "continuous", x = "nominal", x = "ordinal", answer = "date")
```

| Column          | Variable type | Data type     |
|:----------------|:--------------|:--------------|
| `surname`       | `r mcq(nom)`  | `r mcq(chr)`  |
| `firstname`     | `r mcq(nom)`  | `r mcq(chr)`  |
| `sex`           | `r mcq(nom)`  | `r mcq(fctr)` |
| `birthdate`     | `r mcq(date)` | `r mcq(date)` |
| `weight`        | `r mcq(cont)` | `r mcq(num)`  |
| `generalhealth` | `r mcq(ord)`  | `r mcq(fctr)` |

:::



## Building plots

There are multiple approaches to data visualisation in R; in this course we will use the popular package <pkg>ggplot2</pkg>, which is part of the larger `tidyverse` collection of packages. A grammar of graphics (the "gg" in "ggplot") is a standardised way to describe the components of a graphic. <pkg>ggplot2</pkg> uses a layered grammar of graphics, in which plots are built up in a series of layers. It may be helpful to think about any picture as having multiple elements that sit semi-transparently over each other. A good analogy is old Disney movies where artists would create a background and then add moveable elements on top of the background via transparencies.

@fig-layers displays the evolution of a simple scatterplot using this layered approach. First, the plot space is built (layer 1); the variables are specified (layer 2); the type of visualisation (known as a `geom`) that is desired for these variables is specified (layer 3) - in this case `geom_point()` is called to visualise individual data points; a second geom is added to include a line of best fit (layer 4), the axis labels are edited for readability (layer 5), and finally, a theme is applied to change the overall appearance of the plot (layer 6).

```{r fig-layers, fig.cap="Evolution of a layered plot", echo = FALSE, message=FALSE}
function_data <- read_csv(file = "data/Function_and_PA_data.csv",
                        show_col_types = FALSE)

x_breaks <- seq(from = 0.0, to = 1.4, by = 0.2)
y_breaks <- seq(from = 0, to = 10000, by = 2500)

a <- ggplot() + labs(subtitle = "Layer 1")
b <- ggplot(function_data, aes(x = gaitspeed, y = steps)) + 
  labs(subtitle = "Layer 2")
c <- b + geom_point(alpha = 0.2, color = "dodgerblue") + 
  labs(subtitle = "Layer 3")
d <- c + geom_smooth(method = "lm", color = rgb(0, .5, .8)) + 
  labs(subtitle = "Layer 4")
e <- d + scale_x_continuous(name = "Gait speed (m/s)", breaks = x_breaks) +
  scale_y_continuous(name = "Number of steps", breaks = y_breaks) + 
  coord_cartesian(xlim = c(0.0, 1.4), ylim = c(0, 10000)) +
  labs(subtitle = "Layer 5")
f <- e + ggthemes::theme_gdocs(base_size = 10) + 
  theme(axis.line.x = element_blank(),
        plot.background = element_blank()) +
  labs(subtitle = "Layer 6") +
  theme(plot.subtitle =  element_text(color = "black"))

a + b + c + d + e + f + plot_layout(nrow = 2)
```

Importantly, each layer is independent and independently customisable. For example, the size, colour and position of each component can be adjusted, or one could, for example, remove the first geom (the data points) to only visualise the line of best fit, simply by removing the layer that draws the data points (@fig-remove-layer). The use of layers makes it easy to build up complex plots step-by-step, and to adapt or extend plots from existing code.


```{r fig-remove-layer, fig.cap="Final plot with scatterplot layer removed.", echo = FALSE}

ggplot(function_data, aes(x = gaitspeed, y = steps)) + 
  #geom_point(alpha = 0.15, color = "dodgerblue") +
  geom_smooth(method = "lm", formula = y~x, color = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Gait speed (m/s)", breaks = seq(from = 0.0, to = 1.4, by = 0.2)) +
  scale_y_continuous(name = "Number of steps", breaks = seq(from = 0, to = 10000, by = 2500)) + 
  coord_cartesian(xlim = c(0.0, 1.4), ylim = c(0, 10000)) +
  ggthemes::theme_gdocs(base_size = 11) +
  theme(axis.line.x = element_blank(),
        plot.background = element_blank())
```

### Plot Data {#sec-plots-loading-data}

Let's build up the plot above, layer by layer. First we need to get the data. We'll learn how to load data from different sources in @sec-data, but this time we'll use the same method as we did in @sec-loading-online and load it from an online source. 

When you load the data, `read_csv()` will produce a message that gives you information about the data it has imported and what assumptions it has made. The "column specification" tells you what each column is named and what type of data R has categorised each variable as. The abbreviation "chr" is for `r glossary("character")` columns, "dbl" is for `r glossary("double")` columns, and "dttm" is a date/time column.

```{r}
function_data <- read_csv("https://healthteachr.github.io/ads-v2/data/Function_and_PA_data.csv")
```

This data is simulated data for a health and wellbeing study in older adults. The first thing you should do when you need to plot data is to get familiar with what all of the rows (observations) and columns (variables) mean. Sometimes this is obvious, and sometimes it requires help from the data provider. Here, each row represents one participant.

* `id` is a unique ID for each participant
* `CASP19` is a quality-of-life score from a 19-item scale
* `sex` is the biological sex of the participant
* `gaitspeed` is the participant's gait speed in m/s (from an objective 4-metre walking test)
* `age` is the participant's age in years
* `steps` is the number of steps each participant took over a 24-hour period (assessed via an accelerometer)
* `musculoskeletal` is whether the participant reported being diagnosed with any of the following diseases: osteoarthritis, rheumatoid arthritis, osteoporosis, sarcopenia, or none
* `condition_type` is the part of the body affected by the musculoskeletal disease: joints (for osteoarthritis/rheumatoid arthritis), bones (for osteoporosis), muscles (for sarcopenia), or none
* `test_start` is the date and time that the gait speed test started
* `generalhealth` is a self-reported general health rating on a scale from 1 (very poor) to 5 (very good)

Unless you specify the column types, data importing functions will just guess the types and usually default to double for columns with numbers and character for columns with letters. Use the function `spec()` to find out all of the column types and edit them if needed.

```{r}
spec(function_data)
```

Let's set `musculoskeletal` and `condition_type` as factors and set the order of the levels. By default, R will order the levels of a factor alphanumerically, however in many cases you will want or need to set your own order. For example, in this data, it makes most sense for the category "none" to come at the end of the list for both variables. We will also set `sex` as a factor variable. After you update the column types, you have to re-import the data by adjusting the `read_csv()` code to set the `col_types` argument to the new column types.

::: {.callout-note}
## Define objects before you use them

Because `read_csv()` is going to use the object `function_col_types`, you must create `function_col_types` before you run the adjusted `read_csv()` code. If you ever need to adjust your code, try to think about the order that the code will run in if you start from scratch and make sure it's organised appropriately.
:::

```{r}
# updated column types
function_col_types <- cols(
  id = col_character(),
  sex = col_factor(levels = c("Male", "Female")),
  gaitspeed = col_double(),
  age = col_integer(),
  steps = col_integer(),
  musculoskeletal = col_factor(levels = c("Osteoarthritis", "Rheumatoid arthritis", "Osteoporosis", "Sarcopenia", "None")),
  condition_type = col_factor(levels = c("Joints", "Bones", "Muscles", "None")),
  test_start = col_datetime(format = ""),
  generalhealth = col_integer()
)

# re-import data with correct column  types
function_data <- read_csv("https://healthteachr.github.io/ads-v2/data/Function_and_PA_data.csv",
                        col_types = function_col_types)
```


### Plot setup

#### Default theme

Plots in this book use the black-and-white theme, not the default grey theme, so set your default theme to the same so your plots will look like the examples below. At the top of your script, in the setup chunk after you've loaded the tidyverse package, add the following code and run it. You'll learn more ways to customise your theme in @sec-themes and @sec-themes-appendix.

```{r}
theme_set(theme_bw()) # set the default theme
```

#### Data {#sec-plot-setup-data}

Every plot starts with the `ggplot()` function and a data table. If your data are not loaded or you have a typo in your code, this will give you an error message. It's best to check your plot after each step, so that you can figure out where errors are more easily.

```{r fig-build-plot-setup, fig.cap = "A blank ggplot."}
ggplot(data = function_data)
```

#### Mapping

The next `r glossary("argument")` to `ggplot()` is the `mapping`. This tells the plot which columns in the data should be represented by, or "mapped" to, different aspects of the plot, such as the x-axis, y-axis, line colour, object fill, or line style. These aspects, or "aesthetics", are listed inside the `aes()` function.

Set the arguments `x` and `y` to the names of the columns you want to be plotted on those axes. Here, we want to plot gait speed on the x-axis and steps on the y-axis.

```{r fig-build-plot-mapping, fig.cap = "A blank plot with x- and y- axes mapped."}
# set up the plot with mapping
ggplot(
  data = function_data, 
  mapping = aes(x = gaitspeed, y = steps)
)
```

::: {.callout-note}
## ggplot argument names

In the example above, we wrote out the names of the `r glossary("argument", "arguments")` `data` and `mapping`, but in practice, almost everyone omits them. Just make sure you put the data and mapping in the right order.

```{r, eval = FALSE}
ggplot(function_data,  aes(x = gaitspeed, y = steps))
```
:::

#### Geoms

Now we can add our plot elements in layers. These are referred to as `r glossary("geom", "geoms")` and their functions start with `geom_`. You **add** layers onto the base plot created by `ggplot()` with a plus (`+`). 

```{r fig-build-plot-geoms, fig.cap="Adding a scatterplot with geom_point()."}
ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_point() # scatterplot
```

::: {.callout-warning collapse="true"}
## Location of the +

Somewhat annoyingly, the plus has to be on the end of the previous line, not at the start of the next line. If you do make this mistake, it will run the first line of code to produce the base layer but then you will get the following error message rather than adding on `geom_point()`.

```{r, error = TRUE}
ggplot(function_data, aes(x = gaitspeed, y = steps))
+ geom_point() # scatterplot
```
:::

#### Multiple geoms

Part of the power of <pkg>ggplot2</pkg> is that you can add more than one geom to a plot by adding on extra layers and so it quickly becomes possible to make complex and informative visualisation. Importantly, the layers display in the order you set them up. The code below uses the same geoms to produce a scatterplot with a line of best fit, but orders them differently.

```{r fig-build-plot-geom2-code, eval = FALSE}

# Points first
ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_point() + # scatterplot
  geom_smooth(method = lm) # line of best fit

# Line first
ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_smooth(method = lm) + # line of best fit
  geom_point() # scatterplot

```


```{r fig-build-plot-geom2, fig.cap="Points first versus line first.", message = FALSE, echo  = FALSE}
point_first <- 
  ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_point() + # scatterplot
  geom_smooth(method = lm) # line of best fit
  
line_first <-
  ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_smooth(method = lm) + # line of best fit
  geom_point() # scatterplot

# add plots together in 1 row
point_first + line_first + plot_layout(nrow = 1)
```

#### Saving plots

Just like you can save numbers and data tables to objects, you can also save the output of `ggplot()`. The code below produces the same plots we created above but saves them to objects named `point_first` and `line_first`. If you run just this code, the plots won't display like they have done before. Instead, you'll see the object names appear in the environment pane.

```{r, message = FALSE}
point_first <- 
  ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_point() + # scatterplot
  geom_smooth(method = lm) # line of best fit
  
line_first <-
  ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_smooth(method = lm) + # line of best fit
  geom_point() # scatterplot
```

To view the plots, call the objects by name. This will output each plot separately.

```{r, eval = FALSE}
point_first # view first plot
line_first # view second plot
```

#### Combining plots

One of the reasons to save your plots to objects is so that you can combine multiple plots using functions from the `patchwork` package. The below code produces the above plot by combining the two plots with `+` and then specifying that we want the plots produced on a single row with the `nrow` argument in `plot_layout()`. 

```{r, fig-build-plot-geom2b, fig.cap="Combining plots with patchwork.", message = FALSE}
# add plots together in 1 row
point_first + line_first + plot_layout(nrow = 1)
```

::: {.callout-note .try}
## Try changing nrow to 2
:::


### Customising plots

There are nearly endless ways to customise ggplots. We'll cover a few of the basic customisations here.

#### Styling geoms

We should definitely put the line in front of the points, but the points are still a bit dark. If you want to change the overall style of a geom, you can set the arguments `colour`, `alpha`, `shape`, `size` and `linetype` inside the geom function. There are many different values that you can set these to; @sec-plotstyle) gives details of these. Play around with different values below and figure out what the `r glossary("default value", "default values")` are for `shape` and `size`. 

```{r fig-build-plot-style, fig.cap="Changing geom styles."}
ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2, # 20% transparency
             shape = 18,  # solid diamond
             size = 2) + 
  geom_smooth(method = lm, 
              formula = y~x, # formula used to draw line, 
              # setting method & formula avoids an annoying message
              colour = rgb(0, .5, .8),
              linetype = 3) 
```

::: {.callout-warning}
## Setting aesthetics overall versus by category

This method is only for changing the style of *all* the shapes made with that geom. If you want, for example, points to have different colours depending on the type of musculoskeletal disease, you set the argument `colour = musculoskeletal` inside the `aes()` function for the mapping. You can customise the colours used with `scale_` functions, which you will learn about below and in @sec-plotstyle).
:::

#### Format axes

Now we need to make the axes look neater. There are several functions you can use to change the axis labels, but the most powerful ones are the `scale_` functions. You need to use a scale function that matches the data you're plotting on that axis and this is where it becomes particularly important to know what type of data you're working with. Both of the axes here are `r glossary("continuous")`, so we'll use `scale_x_continuous()` and `scale_y_continuous()`.

The `name` argument changes the axis label. The `breaks` argument sets the major units and needs a `r glossary("vector")` of possible values, which can extend beyond the range of the data (e.g., `gaitspeed` only goes up to 1.297, but we can specify breaks up to 1.4 to make the maths easier or anticipate updates to the data). The `seq()` function creates a sequence of numbers `from` one `to` another `by` specified steps.

```{r, filename="Example of seq()"}
seq(from = 0.0, to = 1.4, by = 0.2)
```


```{r fig-build-plot-axes, fig.cap="Formatting plot axes with scale_ functions."}
ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  # customise axis labels and breaks
  scale_x_continuous(name = "Gait speed (m/s)", 
                     breaks = seq(from = 0.0, to = 1.4, by = 0.2)) +
  scale_y_continuous(name = "Number of steps",
                     breaks = seq(from = 0, to = 10000, by = 2500))
```

::: {.callout-note .try}
## Minor breaks

Check the help for `?scale_x_continuous` to see how you would set the minor units or specify how many breaks you want instead.
:::


#### Axis limits

If you want to change the minimum and maximum values on an axis, use the `coord_cartesian()` function. Many plots make more sense if the minimum and maximum values represent the range of possible values, even if those values aren't present in the data. Here, gait speed and number of steps can't be less than 0, so we'll set the minimum values to 0 and the maximum values to the first break above the highest value.

```{r fig-build-plot-limits, fig.cap="Changing the axis limits."}
ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Gait speed (m/s)", 
                     breaks = seq(from = 0.0, to = 1.4, by = 0.2)) +
  scale_y_continuous(name = "Number of steps",
                     breaks = seq(from = 0, to = 10000, by = 2500)) +
  # set axis limits
  coord_cartesian(xlim = c(0.0, 1.4), 
                  ylim = c(0, 10000))
```

::: {.callout-caution}
## Setting limits with the scale_ function

You can also set the `limits` argument inside  the `scale_` functions, but this actually removes any data that falls outside these limits, rather than cropping your plot, and this can change the appearance of certain types of plots like violin plots and density plots.
:::

#### Themes {#sec-themes}

<pkg>ggplot2</pkg> comes with several built-in themes, such as `theme_minimal()` and `theme_bw()`, but the [<pkg>ggthemes</pkg>](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/) package provides even more themes to match different software, such as GoogleDocs or Stata, or publications, such as the Economist or the Wall Street Journal. Let's add the GoogleDocs theme, but change the font size to 20 with the `base_size` argument.

It's also worth highlighting that this code is starting to look quite complicated because of the number of layers, but because we've built it up slowly it should (hopefully!) make sense. If you see examples of <pkg>ggplot2</pkg> code online that you'd like to adapt, build the plot up layer by layer and it will make it easier to understand what each layer adds.

```{r fig-build-plot-theme, fig.cap="Changing the theme to the Google Docs style."}
ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Gait speed (m/s)", 
                     breaks = seq(from = 0.0, to = 1.4, by = 0.2)) +
  scale_y_continuous(name = "Number of steps",
                     breaks = seq(from = 0, to = 10000, by = 2500)) +
  coord_cartesian(xlim = c(0.0, 1.4), 
                  ylim = c(0, 10000)) +
  # change the theme
  ggthemes::theme_gdocs(base_size = 20)
```



#### Theme tweaks

If you're still not quite happy with a theme, you can customise it even further with the `themes()` function. Check the help for this function to see all of the possible options. The most common thing you'll want to do is to remove an element entirely. You do this by setting the relevant argument to `element_blank()`. Below, we're getting rid of the x-axis line and the plot background, which removes the line around the plot.

```{r fig-build-plot-custom-theme, fig.cap="Customising the theme to remove the x-axis line and background outline."}
ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Gait speed (m/s)", 
                     breaks = seq(from = 0.0, to = 1.4, by = 0.2)) +
  scale_y_continuous(name = "Number of steps",
                     breaks = seq(from = 0, to = 10000, by = 2500)) +
  coord_cartesian(xlim = c(0.0, 1.4), 
                  ylim = c(0, 10000)) +
  theme_gdocs(base_size = 11) +
  # customise theme elements
  theme(axis.line.x = element_blank(),
        plot.background = element_blank())
```

### Figure captions {#sec-captions}

You can add a caption directly to the image using the `labs()` function, which also allows you to add or edit the title, subtitle, and axis labels.

```{r fig-caption, fig.cap="Adding a title, subtitle, and caption."}
ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Gait speed (m/s)", 
                     breaks = seq(from = 0.0, to = 1.4, by = 0.2)) +
  scale_y_continuous(name = "Number of steps",
                     breaks = seq(from = 0, to = 10000, by = 2500)) +
  coord_cartesian(xlim = c(0.0, 1.4), 
                  ylim = c(0, 10000)) +
  theme_gdocs(base_size = 11) +
  theme(axis.line.x = element_blank(),
        plot.background = element_blank()) +
  labs(title = "The relationship between gait speed and physical activity",
       subtitle = "2020 Healthy Ageing Data",
       caption = "Figure 1. As gait speed increases, number of steps increases.")
```

However, it is more accessible to include this sort of information in plain text for screen readers. You can add a text caption in the chunk header, and some document types will even automatically number figures for you (you'll learn about this in @sec-linked-docs). You can also add alt-text descriptions for screen readers that describe the image.

```{r, eval = FALSE, verbatim='r fig-gait-vs-steps, fig.cap="As gait speed increases, number of steps increases.", fig.alt="A scatterplot showing gait speed on the x-axis (range 0.0-1.3 m/s) and number of steps on the y-axis (range 0-9829 steps) with a trend line showing that as gait speed increases, number of steps increases from about 0.6m/s gait speed/2400 steps to about 1.2m/s gait speed/7400 steps."'}
# figure code here
```


## Appropriate plots

Now that you know how to build up a plot by layers and customise its appearance, you're ready to learn about some more plot types. Different types of data require different types of plots, so this section is organised by data type. 

The [ggplot2 cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf) is a great resource to help you find plots appropriate to your data, based on how many variables you're plotting and what type they are. The examples below all use the same health and wellbeing data, but each plot communicates something different. 

We don't expect you to memorise all of the plot types or the methods for customising them, but it will be helpful to try out the code in the examples below for yourself, changing values to test your understanding.

### Counting categories

#### Bar plot

If you want to count the number of things per category, you can use `geom_bar()`. You only need to provide a `x` mapping to `geom_bar()` because by default `geom_bar()` uses the number of observations in each group of `x` as the value for `y`, so you don't need to tell it what to put on the y-axis.

```{r fig-bar, fig.cap="A basic bar plot."}
ggplot(function_data, aes(x = condition_type)) +
  geom_bar()
```

::: {.callout-note .try}
## Customising bar plot appearance

You probably want to customise some things, like the colours, order of the columns, and their labels. Inspect the code below and try running it layer by layer to figure out where these things change. The functions `scale_fill_manual()` and `scale_x_discrete()` are new, but work in the same way as the other `scale_` functions. You'll learn more about this in @sec-custom-viz.

```{r custom-bar, webex.hide = "Code"}

ggplot(function_data, aes(x = condition_type, 
                        fill = condition_type)) +
  geom_bar() +
  scale_x_discrete(
    # change axis title
    name = "Type of condition", 
    # change order
    limits = c("Joints", "Bones", "Muscles", "None"), 
    # change labels
    labels = c("Joints", "Bones", "Muscles", "None") 
  ) +
  scale_fill_manual(
    # change colours
    values = c(Joints = "goldenrod", 
               Bones = "darkgreen", 
               Muscles = "dodgerblue3", 
               None = "purple3"),
    # remove the legend
    guide = "none" 
  ) +
  scale_y_continuous(
    name = "", # remove axis title
    # remove the space above and below the y-axis
    expand = expansion(add = 0)
  ) +
  # minimum = 0, maximum = 65
  coord_cartesian(ylim = c(0, 65)) + 
  ggtitle("Number of participants with each type of musculoskeletal condition") # add a title
```
:::

#### Column plot

If your data already have a column with the number you want to plot, you can use `geom_col()` to plot it. We can use the `count()` function to make a table with a row for each `condition_type` and a column called `n` with the number of observations in that category.

```{r}
function_count_data <- count(function_data, condition_type)
function_count_data
```

`r kable(function_count_data)`

The mapping for `geom_col()` requires you to set both the `x` and `y` aesthetics. Set `y = n` because we want to plot the number of musculoskeletal diseases per condition type, and that information is in the column called `n`.

```{r fig-col, fig.cap="A basic column plot."}
ggplot(function_count_data, aes(x = condition_type, y = n)) +
  geom_col()
```


#### Pie chart

Pie charts are a [misleading form of data visualisation](https://www.data-to-viz.com/caveat/pie.html){target="_blank"}, so we won't cover them. We'll cover options for visualising proportions, like waffle, lollipop and treemap plots, in @sec-other-plots.

::: {.callout-note .try}
## Test your understanding

```{r, include = FALSE}
bar <- c(answer = "geom_bar", x = "geom_col")
col <- c(x = "geom_bar", answer = "geom_col")
```


Here is a small data table.

country             | population      | island
:-------------------|----------------:|:--------------
Northern Ireland    | 1,895,510       | Ireland
Wales               | 3,169,586       | Great Britain
Republic of Ireland | 4,937,786       | Ireland
Scotland            | 5,466,000       | Great Britain
England             | 56,550,138      | Great Britain


* What geom would you use to plot the population for each of the 5 countries? `r mcq(col)`
```{r test-counting-categories, echo = FALSE, results='asis'}
opt <- c(answer = "aes(x = country, y = population)",
         x = "aes(x = population, y = country)",
         x = "aes(x = country)",
         x = "aes(x = island)",
         x = "aes(y = population)")
cat("* What mapping would you use? ", longmcq(opt))
```
* What geom would you use to plot the number of countries on each island? `r mcq(bar)`
```{r, echo = FALSE, results='asis'}
opt <- c(x = "aes(x = country, y = population)",
         x = "aes(x = population, y = country)",
         x = "aes(x = country)",
         answer = "aes(x = island)",
         x = "aes(y = population)")
cat("* What mapping would you use? ", longmcq(opt))
```
:::

### One continuous variable {#sec-histogram}

If you have a continuous variable, like number of steps, you can use `geom_histogram()` to show the distribution. Just like `geom_bar()` you are only required to specify the `x` variable. 

A histogram splits the data into "bins" along the x-axis and shows the count of how many observations are in each bin along the y-axis.

```{r fig-histogram, fig.cap="Histogram of steps."}
ggplot(function_data, aes(x = steps)) +
  geom_histogram()
```

You should always set the `binwidth` or number of `bins` to something meaningful for your data (otherwise you get the annoying message above). You might need to try a few options before you find something that looks good and conveys the meaning of your plot -- try changing the values of `binwidth` and `bins` below to see what works best.

```{r eval = FALSE}
# adjust width of each bar
ggplot(function_data, aes(x = steps)) +
  geom_histogram(binwidth = 500)

# adjust number of bars
ggplot(function_data, aes(x = steps)) +
  geom_histogram(bins = 5)
```


By default, the bars start *centered* on 0, so if `binwidth` is set to 500, the first bar would include -250 to 250 steps, which doesn't make much sense. We can set `boundary = 0` so that each bar represents increments of 500 steps *starting* from 0. 

```{r fig-histogram-boundary0, fig.cap="A histogram with the boundary set to 0."}
ggplot(function_data, aes(x = steps)) +
  geom_histogram(binwidth = 500, boundary = 0)
```


Finally, the default style of grey bars is ugly, so you can change that by setting the `fill` and `colour`, as well as using `scale_x_continuous()` to update the axis labels. 

```{r fig-histogram-custom, fig.cap="Histogram with custom styles."}
ggplot(function_data, aes(x = steps)) +
  geom_histogram(binwidth = 250, 
                 boundary = 0, 
                 fill = "white", 
                 color = "black") +
  scale_x_continuous(name = "Number of steps",
                     breaks = seq(0, 10000, 2500))
```

::: {.callout-note .try}
## Test your understanding

Imagine you have a table of the [population for each country in the world](https://population.un.org/wpp/Download/Standard/Population/){target="_blank"} with the columns `country` and `population`. We'll just look at the 76 countries with populations of less than a million.

```{r test-one-continuous, echo = FALSE}
# load data
pop_data <- readxl::read_excel("data/WPP2019_POP_F01_1_TOTAL_POPULATION_BOTH_SEXES.xlsx", skip = 16) %>%
  filter(Type == "Country/Area") %>%
  select(country = 3, population = `2020`) %>%
  mutate(population = round(as.numeric(population) * 1000)) %>%
  filter(population < 1e6)
  
# make plots
ggplot(pop_data, aes(x = population)) +
  scale_x_continuous(breaks = seq(0, 1e6, 1e5),
                     labels = c(paste0(0:9*100, "K"), "1M")) +
  scale_y_continuous(name = "Number of countries") + 
  geom_histogram(binwidth = 1e5, boundary = 0, fill = "white", color = "black")
```


```{r, echo = FALSE, results='asis'}
opts <- c(x = "aes(x = country, y = population)",
          x = "aes(x = population, y = country)",
          answer = "aes(x = population)",
          x = "aes(x = population, y = count)")
cat("* How would you set the mapping for this plot? ", longmcq(opts))
```
* What is the `binwidth` of the histogram? `r mcq(c("1", "100", answer = "100K", "1M"))`
:::

::: {.callout-tip collapse="true"}
## Axis label customisation

If you're curious how we got the x-axis labels to read "100K" instead of "100000", you just need to add a vector of `labels` the same length as `breaks`.

```{r, eval = FALSE}
  scale_x_continuous(breaks = seq(0, 1e6, 1e5),
                     labels = c(paste0(0:9*100, "K"), "1M"))
```
:::

### Grouped continuous variables

There are several ways to compare continuous data across groups. Which you choose depends on what point you are trying to make with the plot.

#### Stacked histogram

In previous plots, we have used `fill` purely for visual reasons, e.g., we changed the colour of the histogram bars to make them look nicer. However, you can also use `fill` to represent another variable so that the colours become meaningful. 

Setting the `fill` aesthetic **in the mapping** will produce different coloured bars for each category of the `fill` variable, in this case `condition_type`. 

```{r, fig.cap="Histogram with categories represented by fill."}
ggplot(function_data, aes(x = steps, fill = condition_type)) +
  geom_histogram(boundary = 0, 
                 binwidth = 250,
                 color = "black")
```


::: {.callout-warning}
## Arguments inside aes()

When you set an aspect to represent the data, you do this inside the `aes()` function for the mapping, not as an argument to the geom. If you try to set this in a geom, you'll get the following error (unless you coincidentally have an object named `condition_type` that is a colour word).

```{r, error = TRUE}
ggplot(function_data, aes(x = steps)) +
  geom_histogram(boundary = 0, 
                 binwidth = 250, 
                 color = "black",
                 fill = condition_type)
```

:::

::: {.callout-tip collapse="true"}
## Area plot alternative

The function `geom_area()` gives a similar effect when `stat = "bin"`. 

```{r, fig.cap="Stacked area plot."}
# area plot
ggplot(function_data, mapping = aes(x = steps, fill = condition_type)) +
  geom_area(stat = "bin", 
            boundary = 0, 
            binwidth = 250, 
            color = "black")
```

:::

#### Dodged histogram

By default, the categories are positioned stacked on top of each other. If you want to compare more than one distribution, you can set the `position` argument of `geom_histogram()` to "dodge" to put the bars for each group next to each other instead of stacking them. However, this can look confusing with several categories. 

```{r fig-histogram-dodge, fig.cap = "A histogram with multiple groups."}

# dodged histogram
ggplot(function_data, aes(x = steps, 
                        fill = condition_type,
                        colour = condition_type))+
  geom_histogram(boundary = 0, 
                 binwidth = 250, 
                 position = "dodge") +
  scale_x_continuous(name = "Number of steps",
                     breaks = seq(0, 10000, 2500))
```


::: {.callout-tip collapse="true"}
## Frequency plot alternative

Alternatively, you can use `geom_freqpoly()` to plot a line connecting the top of each bin (see @sec-freqpoly).

```{r fig-groups-freqpoly, fig.cap = "A frequency plot with multiple groups."}
# frequency plot
ggplot(function_data, aes(x = steps,
                        colour = condition_type)) +
  geom_freqpoly(binwidth = 250, 
                boundary = 0,
                size = 1) +
  scale_x_continuous(name = "Number of steps",
                     breaks = seq(0, 10000, 2500))
```

:::

#### Violin plot

Another way to compare groups of continuous variables is the violin plot. This is like a density plot, but rotated 90 degrees and mirrored - the fatter the violin, the larger proportion of data points there are at that value.

```{r fig-violin-plot, fig.width = 8, fig.height = 2.5, fig.cap = "The default violin plot gives each shape the same area. Set scale='count' to make the size proportional to the number of observations."}
violin_area <- 
  ggplot(function_data, aes(x = condition_type, y = steps)) +
  geom_violin() +
  ggtitle('scale = "area"')

violin_count <- 
  ggplot(function_data, aes(x = condition_type, y = steps)) +
  geom_violin(scale = "count") +
  ggtitle('scale = "count"')

violin_area + violin_count
```

#### Boxplot

Boxplots serve a similar purpose to violin plots (without the giggles from the back row). They don't show you the shape of the distribution, but rather some statistics about it. The middle line represents the `r glossary("median")`; half the data are above this line and half below it. The box encloses the 25th to 75th percentiles of the data, so 50% of the data falls inside the box. The "whiskers" extending above and below the box extend 1.5 times the height of the box, although you can change this with the `coef` argument. The points show `r glossary("outlier", "outliers")` -- individual data points that fall outside of this range.

Boxplots can be horizontal if you swap to x and y columns, and there are many other customisations you can apply.

```{r fig-box-plot, fig.width = 8, fig.height = 2.5, fig.cap = "Boxplots."}
boxplot <- ggplot(function_data, aes(x = condition_type, y = steps)) +
 geom_boxplot() +
  ggtitle("Default vertical boxplot")

custom <- ggplot(function_data, aes(y = condition_type,x = steps)) +
 geom_boxplot(fill = "grey80", 
              outlier.colour = "red",
              outlier.shape = 8,
              coef = 1,   # length of whiskers relative to box
              varwidth = TRUE, # set width proportional to sample size
              notch = FALSE) +
  ggtitle("Customised horizontal boxplot")

boxplot + custom
```


#### Combo plots

Violin plots are frequently layered with other geoms that represent the mean or median values in the data. This is a lot of code; to help your understanding,  run it layer by layer to see how it builds up and change the values throughout the code.

```{r fig-violin-combos, fig.cap="Violin plots combined with different methods to represent means and medians."}
# add fill and colour to the mapping

ggplot(function_data,  aes(x = condition_type, 
                         y = steps,
                         fill = condition_type,
                         colour = condition_type)) +
  scale_x_discrete(name = "Type of condition") +
  scale_y_continuous(name = "Number of steps",
                     breaks = seq(0, 10000, 2500)) +
  coord_cartesian(ylim = c(0, 10000)) +
  guides(fill = "none", colour = "none") + 
  # add a violin plot
  geom_violin(draw_quantiles = 0.5, # adds a line at median (50%) score
              alpha = 0.4) + 
  # add a boxplot
  geom_boxplot(width = 0.25, 
               fill = "white", 
               alpha = 0.75, 
               fatten = 0, # removes the median line
               outlier.alpha = 0) + 
  # add a point that represents the mean
  stat_summary(fun = mean, 
               geom = "point", 
               size = 2) + 
  ggtitle("ViolinBox")
```

::: {.callout-caution collapse="true"}
## Misleading Bar Charts

A very common type of plot is to produce a bar chart of means, however, the example below demonstrates just how misleading this is. It communicates the mean value for each category, but the bars hide the distribution of the actual data. You can't tell if most gait speeds among participants with a musculoskeletal disease are close to 0.8 m/s, or spread from 0 to 1.4 m/s, or if the vast majority are less than 0.7 m/s, but the mean is pulled up by some very high outliers.

Column plots can also be very misleading. The plot on the left starts the y-axis at 0, which makes the bar heights proportional, showing almost no difference in average gait speeds among participants with a musculoskeletal disease. Since the differences are hard to see, you may be tempted to start the y-axis higher, but that makes it look like the average gait speed for people with muscular conditions is double that for people with bone conditions.

```{r fig-col-plot-bad, fig.height = 2.5, fig.width = 8, message=FALSE, echo = FALSE, fig.cap="Don't plot continuous data with column plots. They are only appropriate for count data."}
tall_col <- ggplot(function_data, aes(x = condition_type, 
                                    y = gaitspeed,
                                    fill = condition_type)) +
  scale_x_discrete(name = "Type of condition") +
  scale_y_continuous(name = "Gait speed (m/s)",
                     breaks = seq(0, 1.4, 0.2)) +
  guides(fill = "none", colour = "none") +
  stat_summary(fun = "mean", 
               geom = "col") # draws a column representing the mean

short_col <- tall_col +
  scale_y_continuous(name = "Gait speed (m/s)",
                     breaks = seq(0, 1.4, 0.2)) +
  coord_cartesian(ylim = c(0.65, 1.15))

tall_col + short_col
```


:::

::: {.callout-note .try}
## Test your understanding

```{r test-grouped-continuous, echo=FALSE, fig.height = 2.5}
box <- c(x = "geom_box()",
         answer = "geom_boxplot()",
         x = "geom_violin()",
         x = "geom_violinplot()")

violin <- c(x = "geom_box()",
         x = "geom_boxplot()",
         answer = "geom_violin()",
         x = "geom_violinplot()")

median <- c(x = "mean",
            answer = "median",
            x = "mode")

e04 <- setNames(faux::make_id(10, "e", 2), rep("x", 10))
e07 <- e04
names(e04)[4] <- "answer"
names(e07)[7] <- "answer"

aes <- sample(c(
  answer = "aes(x = musculoskeletal, y = gaitspeed, fill = musculoskeletal)",
  x = "aes(x = musculoskeletal, y = gaitspeed, fill = gaitspeed)",
  x = "aes(x = musculoskeletal, y = gaitspeed, colour = gaitspeed)",
  x = "aes(x = musculoskeletal, y = gaitspeed, colour = musculoskeletal)"
))

g <- ggplot(function_data, aes(x = musculoskeletal, y = gaitspeed, fill = musculoskeletal)) +
  guides(fill = "none")+theme(axis.text.x=element_text(angle=90,vjust=0.5,hjust=1))
  
v <- g + geom_violin(draw_quantiles = 0.5)
b <- g + geom_boxplot()

v + b + plot_annotation(tag_levels = "A")

ans1 <- sample(c(
  x = "None",
  x = "Osteoarthritis",
  answer = "Osteoporosis",
  x = "Rheumatoid arthritis",
  x = "Sarcopenia"
))

ans2 <- sample(c(
  answer = "None",
  x = "Osteoarthritis",
  x = "Osteoporosis",
  x = "Rheumatoid arthritis",
  x = "Sarcopenia"
))
```

* How would you create plot A? `r mcq(violin)`
* How would you create plot B? `r mcq(box)`
* What does the mapping look like for both plots? `r longmcq(aes)`
* Which musculoskeletal disease is characterised by the slowest median gait speed? `r mcq(ans1)`
* Which musculoskeletal disease is characterised by the quickest median gait speed? `r mcq(ans2)`
:::


### Two continuous variables

When you want to see how two continuous variables are related, set one as the x-axis and the other as the y-axis. Usually, if one variable causes the other, you plot the cause on the x-axis and the effect on the y-axis. Here, we want to see if quicker gait speeds (better physical function) cause the number of steps walked in a 24-hour period to be higher (more physical activity). 

#### Scatterplot

The function to create a scatterplot is called `geom_point()`.

```{r fig-demo-point, fig.cap="Scatterplot with geom_point()."}
ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_point()
```

#### Trendlines

In @fig-layers, we emphasised the relationship between gait speed and number of steps with a trendline created by `geom_smooth()` using the argument `method = lm` ("lm" stands for "linear model" or a straight line relationship). You can also set `method = loess` to visualise a non-linear relationship.

```{r fig-2-continuous, fig.cap="Different ways to show the relationship between two continuous variables."}

lm_plot <- 
  ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = lm, formula = y~x) +
  ggtitle("method = lm")

loess_plot <- 
  ggplot(function_data, aes(x = gaitspeed, y = steps)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = loess, formula = y~x) +
  ggtitle("method = loess")

lm_plot + loess_plot
```

::: {.callout-warning}
## Error shading

If there isn't much data at the extremes of the x-axis, the curve can be very uncertain. This is represented by the wider shaded area, which means that the true relationship might be anywhere within that area. Add the argument `se = FALSE` to `geom_smooth()` to remove this "standard error" shading.
:::


#### Dates

The `test_start` column contains both a date and a time, so use the `date()` function from <pkg>lubridate</pkg> to convert it to just a date. We'll need it in this format to be able to transform the x-axis below.

```{r fig-date-x, fig.cap="Plotting dates."}
ggplot(function_data, aes(x = lubridate::date(test_start), 
                        y = CASP19)) + 
  geom_smooth(method = lm, formula = y~x)
```

We can use `scale_x_date()` to set the `date_breaks` to be "1 month" apart. The `date_labels` argument uses a code for different date formats; you can see the full list of possibilities in the help for `?strptime`. For example, `%b` means "Abbreviated month name", whilst if you wanted to use a format like "2020/01/31" you could try `"%Y/%m/%d"`.

```{r fig-date-month, fig.cap="Plotting dates with breaks one month apart."}
ggplot(function_data, aes(x = lubridate::date(test_start), 
                        y = CASP19)) +
  geom_smooth(method = lm, formula = y~x) +
  scale_x_date(name = "",
               date_breaks = "1 month", 
               date_labels = "%b") +
  scale_y_continuous(name = "Quality-of-life") +
  ggtitle("2020 Quality-of-life")
```

::: {.callout-note .try}
## Test yourself

It looks like quality-of-life scores declined across the year (`test_start` represents the day of data collection here, but can be used as a proxy to investigate seasonal differences in quality-of-life), but is this change meaningful? See what the plot looks like when the y-axis spans the full range of possible quality-of-life values from 0 to 57. You can also plot the individual data points to emphasise the range of values. 

```{r, webex.hide = TRUE}
ggplot(function_data, aes(x = lubridate::date(test_start), 
                        y = CASP19)) +
  # show individual data, jitter the height to avoid overlap
  geom_jitter(width = 0, height = .1, alpha = 0.2) + 
  geom_smooth(method = lm,  formula = y~x) +
  scale_x_date(name = "",
               date_breaks = "1 month", 
               date_labels = "%b") +
  scale_y_continuous(name = "Quality-of-life",
                     breaks = seq(0, 57, 10)) +
  coord_cartesian(ylim = c(0, 57)) + # changes limits
  ggtitle("2020 Quality-of-life")
```

:::


### Overplotting

When you have a limited range of numeric values, such as an ordinal rating scale, sometimes overlapping data makes it difficult to see what is going on in a point plot. For example, the plot below shows general health ratings by gait speed, but because all the ratings are 1, 2, 3, 4 or 5, it makes it hard to see exactly how many data points there are at each point.

In this section, we'll explore a few options for dealing with this.

```{r fig-over-plot, fig.cap="Overlapping data makes plots hard to understand."}
ggplot(function_data, aes(x = gaitspeed, y = generalhealth)) + 
  geom_point()
```

#### Jitter plot

You can use `geom_jitter()` to move the points around a bit to make them easier to see. You can also set alpha transparency. Here, the x-axis is continuous, so there is no need to jitter the `width`, but the y-axis is ordinal categories, so the `height` is jittered between -0.2 and +0.2 away from the true y-value. 

::: {.callout-note .try}
## Change these values to understand what jitter is doing
:::

```{r fig-jitter-plot, fig.cap = "Jitter plot."}
ggplot(function_data, aes(x = gaitspeed, y = generalhealth)) +
  geom_jitter(width = 0, height = .2, alpha = 0.5)
```

#### Facets

Alternatively, you can use `facet_wrap()` to create a separate plot for each level of general health. `facet_wrap()` uses the tilde (~) symbol, which you can roughly translate as "by", e.g., facet the plot *by* general health rating. The `labeller` function controls the labels above each plot. `label_both` specifies that we want both the variable name (generalhealth) and the value (e.g., 1) printed on the plot to make it easier to read.

```{r fig-fact-plot, fig.height = 8, fig.cap = "A histogram with facets."}
ggplot(function_data, aes(x = gaitspeed)) +
  geom_histogram(binwidth = 0.05, 
                 boundary = 0, 
                 fill = "dodgerblue", 
                 color = "black") +
  facet_wrap(~generalhealth, 
             ncol = 1, # try changing this to 2 
             labeller = label_both) +
  scale_x_continuous(name = "Gait speed (m/s)",
                     breaks = seq(0.0, 1.4, 0.2))
```

::: {.callout-note}
## More plots styles

These are not, by any means, all the plot types that you can make in R. This chapter just gave you a basic overview, and we will go into more detail in @sec-custom-viz). The [further resources](#resources-viz) section at the end of this chapter lists many resources, but the [R Graph Gallery](http://www.r-graph-gallery.com/){target="_blank"} is especially useful to get inspiration for the kinds of beautiful plots you can make in R. 
:::

## Exercises

For the final step in this chapter, we will create a report of data visualisations. You may need to refer back to @sec-reports) to help you complete these exercises and you may also want to take a break before you work through this section. We'd also recommend you `r glossary("knit")` at every step so that you can see how your output changes.

### New Markdown {#sec-exercises-new-rmd-3}

Create and save a new R Markdown document named `plots_report.Rmd` and give it the title "Healthy ageing report". Remove the default template text and then load the packages and code below in the set-up code chunk:

```{r setup-report, message=FALSE}
library(tidyverse) 
library(patchwork) 
library(ggthemes)  
library(lubridate) 
library(knitr)
library(kableExtra)

function_data <- read_csv("https://healthteachr.github.io/ads-v2/data/Function_and_PA_data.csv")
```

### Summary {#sec-exercises-summary}

Create a level 1 heading titled "Overview". Underneath this heading, write a short summary of what the data set contains and what each of the variables means (you can use the information from @sec-plots-loading-data if you like).

### Presenting plots

Pick your two favourites plots from all the examples we've made in this chapter. For each plot:

* Create a level 2 heading in your R Markdown document and give it an informative title.
* Write a short summary that interprets the data shown in the plots - it's not enough just to present visualisations, effective reports will also help the reader understand the conclusions they should draw from the plots you've presented.
* Look through the different themes available with [<pkg>ggtheme</pkg>](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/) and  choose one to apply to your plots.
* Make sure each plot has a figure caption (either by adding this to the `ggplot()` code or adding it to the code chunk options).
* Organise your Markdown so that the plots are shown **after** the text summary.

### Combining plots

Now, pick your two least favourite plots:

* Adjust the visual aesthetics to make them look as bad and as difficult to read as possible.
* Combine the plots with the original version using patchwork functions.
* Write a short summary that explains why you think these plots are so bad.
* Organise your Markdown so that the plots are shown **after** the text summary.

### Editing your Markdown display

Adjust the set-up of your Markdown so that your knitted report does not show any code, messages, or warnings, and all figures are 8 x 5 (see @sec-rmd-setup).


### Share your work

Once you've completed this activity, post it in the Week 3 channel on Teams so that you can compare which plots you chose and visual style with other learners on the course.

## Glossary {#sec-glossary-viz}

```{r, echo = FALSE, results='asis'}
glossary_table(as_kable = FALSE) |> 
  kableExtra::kable(row.names = FALSE, escape = FALSE) |>
  unclass() |> cat()
```


## Further Resources {#sec-resources-viz}

* [ggplot2 cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf)
* [Data visualisation using R, for researchers who don't use R](https://healthteachr.github.io/introdataviz/) [@nordmann_2021]
* [Chapter 3: Data Visualisation](http://r4ds.had.co.nz/data-visualisation.html) of *R for Data Science*
* [ggplot2 FAQs](https://ggplot2.tidyverse.org/articles/)
* [ggplot2 documentation](https://ggplot2.tidyverse.org/reference/)
* [Hack Your Data Beautiful](https://healthteachr.github.io/hack-your-data/) workshop by University of Glasgow postgraduate students
* [Chapter 28: Graphics for communication](http://r4ds.had.co.nz/graphics-for-communication.html) of *R for Data Science*
* [gganimate](https://gganimate.com/): A package for making animated plots

