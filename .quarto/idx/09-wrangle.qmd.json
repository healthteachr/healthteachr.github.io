{"title":"Data Wrangling","markdown":{"headingText":"Data Wrangling","headingAttr":{"id":"sec-wrangle","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n## Intended Learning Outcomes {#sec-ilo-wrangle .unnumbered}\n\n* Be able to select and filter data for relevance\n* Be able to create new columns and edit existing ones\n* Be able to handle missing data\n\n## Walkthrough video {#sec-walkthrough-wrangle .unnumbered}\n\nThere is a walkthrough video of this chapter available via [Echo360.](https://echo360.org.uk/media/dc1e2869-a6c2-45d8-ab40-cb85cdb67f43/public) Please note that there may have been minor edits to the book since the video was recorded. Where there are differences, the book should always take precedence.\n\n## Set-up {#sec-setup-wrangle}\n\nFirst, create a new project for the work we'll do in this chapter named `r path(\"09-wrangle\")`. Second, open and save and new R Markdown document named `wrangle.Rmd`, delete the welcome text and load the required packages for this chapter.\n\n```{r setup-wrangle, message=FALSE, filename=\"Chapter packages\"}\nlibrary(tidyverse)   # data wrangling functions\n```\n\nYou'll need to make a folder called \"data\" and download a data file into it: \n<a href=\"https://healthteachr.github.io/ads-v2/data/velocity.csv\" download>velocity.csv</a>.\n\nDownload the [Data transformation cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf).\n\n## Wrangling functions\n\nData wrangling refers to the process of cleaning, transforming, and restructuring your data to get it into the format you need for analysis and it's something you will spend an awful lot of time doing. Most `r glossary(\"data wrangling\")` involves the reshaping functions you learned in @sec-tidy and six functions from the <pkg>dplyr</pkg> package that is loaded as part of the <pkg>tidyverse</pkg>: `select`, `filter`, `arrange`, `mutate`, `summarise`, and `group_by`. You'll remember the last two from @sec-summary, so we'll only cover them briefly.\n\nIt's worth highlighting that in this chapter we're going to cover these common functions and common uses of said functions. However, <pkg>dplyr</pkg> (and packages beyond it) has a huge number of additional wrangling functions and each function has many different arguments. Essentially, if you think you should be able to wrangle your data in a particular way that we haven't explicitly shown you, you almost certainly can, it might just take a bit of Googling to find out how. \n\n```{r, echo = FALSE, eval = FALSE}\nset.seed(8675309)\nvelocity <- faux::sim_design(\n  between = list(\n    position = c(\"bunched\", \"medium\", \"elongated\"),\n    angle = c(\"<50 degrees\", \">50 degrees\")\n  ),\n  within = list(\n    kinematics = c(\"velocity\"),\n    year = 2022:2023\n  ),\n  n = 1,\n  mu = rep(c(3.1,3.4), each = 3, times = 2),\n  sd = 0.1,\n  plot = FALSE\n) %>%\n  mutate_if(is.numeric, round,2) %>%\n  select(-id) %>%\n  mutate(satisfaction_2022 = c(\"low\", \"very low\", \"very high\", \"high\", \"neutral\", \"high\"),\n         satisfaction_2023 = c(\"very low\", \"very high\", \"very high\", \"low\", \"high\", \"neutral\"))\nvelocity$position<-as.character(velocity$position)\nvelocity$angle<-as.character(velocity$angle)\n\nwrite_csv(velocity, \"data/velocity.csv\")\n```\n\nWe'll use a small example table with a sprinter's velocity out of the blocks (m/s) and performance satisfaction for two years from three starting block positions (bunched: <30 cm spacing between blocks; medium: 30-35 cm spacing between blocks; elongated: >35 cm spacing between blocks) over two block angles. After you load the data, use `glimpse(velocity)` or `View(velocity)` to get familiar with the data.\n\n```{r}\nvelocity <- read_csv(\"data/velocity.csv\", show_col_types = FALSE)\n```\n\n```{r, echo = FALSE}\nvelocity\n```\n\n\n### Select\n\nYou can select a subset of the columns (variables) in a table to make it easier to view or to prepare a table for display. You can also select columns in a new order.\n\n#### By name or index\n\nYou can select columns by name or number (which is sometimes referred to as the column index). Selecting by number can be useful when the column names are long or complicated.\n\n```{r}\n# select single column by name\nblock_angle_dat <- velocity %>% select(angle) \n\n# select single column by number\nblock_angle_dat <- velocity %>% select(2) \n```\n\nYou can select each column individually, separated by commas (e.g., `position, velocity_2022`) but you can also select all columns from one to another by separating them with a colon (e.g., `velocity_2022:satisfaction_2023`).\n\nThe colon notation can be much faster because you don't need to type out each individual variable name, but make sure that you know what order your columns are in and always check the output to make sure you have selected what you intended.\n\n```{r select-name}\n# select columns individually\nvelocity2022 <- velocity %>% select(position, angle, velocity_2022)\n\n# select columns with colon\nvelocity2022 <- velocity %>% select(position:velocity_2022)\n```\n\nYou can rename columns at the same time as selecting them by setting `new_name = old_col`. \n\n```{r select-number}\npositions <- velocity %>% select(`Space between blocks` = 1, 3:6)\n\nhead(positions, 2)\n```\n\n#### Un-selecting columns\n\nYou can select columns either by telling R which ones you want to keep as in the previous examples, or by specifying which ones you want to exclude by using a minus symbol to un-select columns. You can also use the colon notation to de-select columns, but to do so you need to put parentheses around the span first, e.g., `-(velocity_2022:velocity_2023)`, not `-velocity_2022:velocity_2023`.\n\n```{r select-unselect}\n# de-select individual columns\nsatisfaction <- velocity %>% select(-velocity_2022, -velocity_2023)\n\n# de-select a range of columns\nsatisfaction <- velocity %>% select(-(velocity_2022:velocity_2023))\n```\n\n#### Select helpers\n\nFinally, you can select columns based on criteria about the column names.\n\n| function | definition |\n|----------|------------|\n| `starts_with()` | select columns that start with a character string|\n| `ends_with()` | select columns that end with a character string |\n| `contains()` | select columns that contain a character string |\n| `num_range()` | select columns with a name that matches the pattern `prefix` |\n\n```{r select-helpers, echo = FALSE}\nx1 <- velocity %>% select(starts_with(\"velocity\"))\nx2 <- velocity %>% select(ends_with(\"2023\"))\nx3 <- velocity %>% select(contains(\"_\"))\nx4 <- velocity %>% select(num_range(\"velocity_\", 2022:2023))\n\na <- list(names(x1), names(x2), names(x3), names(x4)) %>%\n  sapply(paste, collapse = \", \")\n\na1 <- setNames(a, c(\"answer\", \"x\", \"x\", \"x\")) %>% longmcq()\na2 <- setNames(a, c(\"x\", \"answer\", \"x\", \"x\")) %>% longmcq()\na3 <- setNames(a, c(\"x\", \"x\", \"answer\", \"x\")) %>% longmcq()\na4 <- setNames(a, c(\"x\", \"x\", \"x\", \"answer\")) %>% longmcq()\n```\n\n\n::: {.callout-note .try}\nWhat are the resulting columns for these four examples?\n\n* `velocity %>% select(contains(\"_\"))`\n    `r a3`\n* `velocity %>% select(num_range(\"velocity_\", 2022:2023))`\n    `r a4`\n* `velocity %>% select(starts_with(\"velocity\"))`\n    `r a1` \n* `velocity %>% select(ends_with(\"2023\"))`\n    `r a2`\n:::\n\n\n### Filter\n\nWhilst `select()` chooses the columns you want to retain, `filter()` chooses the rows to retain by matching row or column criteria.\n\nYou can filter by a single criterion. This criterion can be rows where a certain column's value matches a character value (e.g., \"elongated\") or a number (e.g., 3.51). It can also be the result of a logical equation (e.g., keep all rows with a specific column value larger than a certain value). The criterion is checked for each row, and if the result is FALSE, the row is removed. You can reverse equations by specifying `!=` where `!` means \"not\".\n\n```{r filter, eval = FALSE}\n# select all rows where position equals elongated\nvelocity %>% filter(position == \"elongated\")\n\n# select all rows where velocity_2023 was exactly equal to 3.51\nvelocity %>% filter(velocity_2023 == 3.51)\n\n# select all rows where velocity_2022 was more than 3.1\nvelocity %>% filter(velocity_2022 > 3.1)\n\n# everything but the elongated starting block position\nvelocity %>% filter(position != \"elongated\")\n```\n\n::: {.callout-warning}\nRemember to use `==` and not `=` to check if two things are equivalent. A single `=` assigns the right-hand value to the left-hand variable (much like the `<-` operator).\n:::\n\n\n```{r filter-mcq, echo = FALSE}\nclass <- tibble(id = 1:4, \n               grade = c(\"A\", \"A\", \"C\", \"B\"),\n               score = c(95, 91, 76, 84)\n               )\nx1 <- which(class$grade == \"A\")\nx2 <- which(class$score == 91)\nx3 <- which(class$score < 80)\nx4 <- which(class$grade != \"A\")\n\na <- list(x1, x2, x3, x4) %>%\n  sapply(paste, collapse = \", \")\n\na1 <- setNames(a, c(\"answer\", \"x\", \"x\", \"x\")) %>% mcq()\na2 <- setNames(a, c(\"x\", \"answer\", \"x\", \"x\")) %>% mcq()\na3 <- setNames(a, c(\"x\", \"x\", \"answer\", \"x\")) %>% mcq()\na4 <- setNames(a, c(\"x\", \"x\", \"x\", \"answer\")) %>% mcq()\n```\n\n\n::: {.callout-note .try}\nWhich IDs are kept from the table below?\n\n```{r, echo = FALSE}\nclass\n```\n\n* `demo %>% filter(score < 80)`\n    `r a3`\n* `demo %>% filter(grade == \"A\")`\n    `r a1`\n* `demo %>% filter(grade != \"A\")`\n    `r a4`\n* `demo %>% filter(score == 91)`\n    `r a2`\n    \n\n:::\n\nYou can also select on multiple criteria by separating them by commas (rows will be kept if they match *all* criteria). Additionally, you can use `&` (\"and\") and `|` (\"or\") to create complex criteria.\n\n```{r filter-symbols}\n# positions and angles with improvement in velocity from 2022 to 2023 and with \"very high\" satisfaction in 2023\nimprovement_and_satisfaction <- velocity %>% \n  filter(\n    velocity_2023 > velocity_2022,\n    satisfaction_2023==\"very high\"\n  )\n\n# the same as above, using & instead of a comma\nimprovement_and_satisfaction <- velocity %>% \n  filter(\n    velocity_2023 > velocity_2022 &\n    satisfaction_2023==\"very high\"\n  )\n\n# positions and angles with improvement in velocity from 2022 to 2023 or with \"very high\" satisfaction in 2023\nimprovement_or_satisfaction <- velocity %>% \n  filter(\n    velocity_2023 > velocity_2022 |\n    satisfaction_2023==\"very high\"\n  )\n\n# Improvement in velocity between 2022 and 2023 greater than 0.2 m/s\nbig_improvement <- velocity %>%\n  filter(velocity_2023 - velocity_2022 > 0.2)\n\n```\n\nIf you want the filter to retain multiple specific values in the same variable, the `r glossary(\"match operator\")` (`%in%`) should be used rather than `|` (or). The `!` can also be used in combination here, but it is placed before the variable name.\n\n```{r match-operator, eval = FALSE}\n# retain any rows where position is bunched or medium, and where angle equals <50 degrees\nvelocity %>%\n  filter(position %in% c(\"bunched\", \"medium\"),\n         angle == \"<50 degrees\")\n\n# retain any rows where the position is not elongated, and where the angle does not equal <50 degrees\nvelocity %>%\n  filter(!position %in% \"elongated\",\n         angle != \"<50 degrees\")\n```\n\n`r glossary(\"Operator\")`\t|Name   |is TRUE if and only if\n-----------|----------------------|---------------------------------\n`A < B`    |less than \t          |A is less than B\n`A <= B`   |less than or equal    |A is less than or equal to B\n`A > B`    |greater than \t        |A is greater than B\n`A >= B`   |greater than or equal |A is greater than or equal to B\n`A == B`   |equivalence \t        |A exactly equals B\n`A != B`   |not equal \t          |A does not exactly equal B\n`A %in% B` |in \t                  |A is an element of vector B\n\nFinally, you can also pass many other functions to filter. For example, the package <pkg>stringr</pkg> that is loaded as part of the <pkg>tidyverse</pkg> contains many different functions for working with `r glossary(\"string\", \"strings\")` (character data). For example, you you use `str_detect()` to only retain rows where the performance satisfaction rating includes the word \"high\".\n\n```{r eval = TRUE}\nvelocity %>%\n  filter(str_detect(satisfaction_2022, \"high\"))\n```\n\nNote that `str_detect()` is case sensitive so it would not return values of \"High\" or \"HIGH\". You can use the function `tolower()` or `toupper()` to convert a string to lowercase or uppercase before you search for substring if you need case-insensitive matching.\n\n::: {.callout-warning}\n`filter()` is incredibly powerful and can allow you to select very specific subsets of data. But, it is also quite dangerous because when you start combining multiple criteria and operators, it's very easy to accidentally specify something slightly different than what you intended. **Always check your output**. If you have a small dataset, then you can eyeball it to see if it looks right. With a larger dataset, you may wish to compute summary statistics or count the number of groups/observations in each variable to verify your filter is correct. There is no level of expertise in coding that can substitute knowing and checking your data. \n:::\n\n### Arrange\n\nYou can sort your dataset using `arrange()`. You will find yourself needing to sort data in R much less than you do in Excel, since you don't need to have rows next to each other in order to, for example, calculate group means. But `arrange()` can be useful when preparing data for display in tables. `arrange()` works on character data where it will sort alphabetically, as well as numeric data where the default is ascending order (smallest to largest). Reverse the order using `desc()`.\n\n```{r arrange}\n# arranging the table \n# first by angle in alphabetical order\n# then by \"position\" in reverse alphabetical order\nvelocity %>%\n  arrange(angle, desc(position))\n```\n\n\n::: {.callout-note .try}\nIf you want to sort character data/categories in a specific order, turn the column into a `r glossary(\"factor\")` and set the `levels` in the desired order.\n\n```{r}\nvelocity %>%\n  mutate(position = factor(position, levels = c(\"bunched\", \"medium\", \"elongated\"))) %>%\n  filter(angle == \">50 degrees\") %>%\n  arrange(position)\n```\n\n:::\n\n### Mutate\n\nThe function `mutate()` allows you to add new columns or change existing ones by overwriting them by using the syntax `new_column = operation`.  You can add more than one column in the same mutate function by separating the columns with a comma. Once you make a new column, you can use it in further column definitions. For example, the creation of `improvement_percent` below uses the column `improvement_raw`, which is created above it.\n\n```{r mutate}\nvelocity2 <- velocity %>%\n  mutate(\n    improvement_raw = velocity_2023 - velocity_2022,\n    improvement_percent = (improvement_raw / velocity_2022) * 100,\n    position = paste(position, \"start\")\n  )\n```\n\n`mutate()` can also be used in conjunction with other functions and Boolean operators. For example, we can add another column to `velocity2` that states whether there was an improvement in velocity out of the blocks that year or overwrite our `angle` variable as a factor. Just like when we used `r glossary(\"boolean expression\", \"Boolean expressions\")` with filter, it will evaluate the equation and return TRUE or FALSE depending on whether the observation meets the criteria.\n\n```{r}\nvelocity2 <- velocity2 %>%\n  mutate(improvement_category = improvement_raw > 0,\n         angle = as.factor(angle))\n```\n\n::: {.callout-warning}\nYou can overwrite a column by giving a new column the same name as the old column (see `position` or `angle`) above. Make sure that you mean to do this and that you aren't trying to use the old column value after you redefine it.\n:::\n\nYou can also use `case_when()` to specify what values to return, rather than defaulting to TRUE or FALSE:\n\n```{r}\nvelocity3 <- velocity2 %>%\n  mutate(improvement_category = case_when(improvement_raw > 0 ~ \"IMPROVEMENT\",\n                                     improvement_raw < 0 ~ \"NO IMPROVEMENT\"))\n```\n\nUse it to recode values:\n\n```{r}\n# create a column where coaches get a bonus if the sprinter's performance satisfaction was overall high or very high\n\nbonus <- velocity3 %>%\n  mutate(bonus_2022 = case_when(satisfaction_2022 %in% c(\"very low\", \"low\", \"neutral\") ~ \"no bonus\",\n                                satisfaction_2022 %in% c(\"high\", \"very high\") ~ \"bonus\"))\n```\n\nAnd combine different criteria:\n\n```{r}\n\n# new club management takes over - coaches only get a bonus if performance satisfaction was overall high or very high AND there was an improvement in performance\n\nbonus2 <- velocity3 %>%\n  mutate(bonus_2023 = case_when(satisfaction_2023 == \"high\" & \n                                  improvement_category == \"IMPROVEMENT\" ~ \"bonus\",\n                                satisfaction_2023 == \"very high\" & \n                                  improvement_category == \"IMPROVEMENT\" ~ \"bonus\",\n                                TRUE ~ \"No bonus\")) # set all other values to \"no bonus\"\n```\n\nJust like `filter()`, `mutate()` is incredibly powerful and the scope of what you can create is far beyond what we can cover in this book. \n\n### Summarise {#sec-dplyr-summarise}\n\nYou were introduced to the `summarise()` function in @sec-summary-summarise. This applies summary functions to an entire table (or groups, as you'll see in the next section).\n\nLet's say we want to determine the mean velocity, plus the minimum and maximum velocity, for any starting block position, block angle, and year. First, we need to reshape the data like we learned in @sec-tidy, so that there is a column for year and one column for velocity, instead of separate columns for each year. We'll also drop the satisfaction data as we don't need it for this analysis. \n\n```{r}\nvelocity4 <- velocity %>%\n  select(-satisfaction_2022, -satisfaction_2023) %>%\n  pivot_longer(cols = velocity_2022:velocity_2023,\n               names_to = c(\"velocity\", \"year\"),\n               names_sep = \"_\",\n               values_to = \"value\") %>%\n  pivot_wider(names_from = velocity,\n              values_from = value)\n\nhead(velocity4) # check the format\n```\n\nNow we can create summary statistics for the table.\n\n```{r}\nvelocity4 %>%\n  summarise(\n    mean_velocity = mean(velocity),\n    min_velocity = min(velocity),\n    max_velocity = max(velocity)\n  )\n```\n\n### Group By {#sec-dplyr-groupby}\n\nYou were introduced to the `group_by()` function in @sec-grouping. For example, you can break down the summary statistics above by year and block angle.\n\n```{r}\nyear_angle <- velocity4 %>%\n  group_by(year, angle) %>%\n  summarise(\n    mean_velocity = mean(velocity),\n    min_velocity = min(velocity),\n    max_velocity = max(velocity)\n  ) %>%\n  ungroup()\n\nyear_angle\n```\n\n\nNote that you can use the other wrangling functions on the summary table, for example: \n\n```{r eval = FALSE}\n# arrange by maximum velocity\nyear_angle %>%\n  arrange(desc(max_velocity))\n\n# filter out block angles of >50 degrees\nyear_angle %>%\n  filter(angle != \">50 degrees\")\n\n```\n\n\n::: {.callout-note .try}\nHow would you find out the maximum velocity for each starting block position?\n\n```{r, results='asis', echo = FALSE}\nc(answer = \"<pre>velocity3 %>%\\n  group_by(position) %>%\\n  summarise(max_velocity = max(velocity)</pre>\",\n  x = \"<pre>velocity3 %>%\\n  group_by(position) %>%\\n  summarise(max_velocity = max(position)</pre>\",\n  x = \"<pre>velocity3 %>%\\n  group_by(velocity) %>%\\n  summarise(max_velocity = max(velocity)</pre>\",\n  x = \"<pre>velocity3 %>%\\n  group_by(velocity) %>%\\n  summarise(max_velocity = max(position)</pre>\") %>%\n  sample() %>% webexercises::longmcq() %>% cat()\n```\n\n:::\n\nYou can also use `group_by()` in combination with other functions. For example, `slice_max()` returns the top N rows, ordered by a specific variable.\n\n```{r}\n# return top 3 velocities\nvelocity4 %>%\n  slice_max(n = 3, order_by = velocity)\n```\n\nBut this can be combined with `group_by()` to return the top velocity for each starting block position:\n\n```{r}\n# return top velocity for each position\nvelocity4 %>%\n  group_by(position) %>%\n  slice_max(n = 1, order_by = velocity)\n```\n\n## Complications\n\n### Rounding\n\nLet's say we want to round all the values to zero decimal places. The pattern below uses the `across()` function to apply the `round()` function to the columns from `mean_velocity` to `max_velocity`.\n\n```{r}\nyear_angle %>%\n  mutate(across(.cols = mean_velocity:max_velocity, \n                .fns = round))\n```\n\nPlease note that R rounds .5 to the nearest even number, rather than always up, like you were probably taught in school. This prevents overestimation biases, since x.5 is *exactly* halfway between x and x+1, so there is no reason it should always round up.\n\n```{r}\nround(0.5)\nround(1.5)\n```\n\nHowever, this might throw a monkey wrench into your own systems. For example, a school policy might be to round up for course marks at x.5. The solution is to define your own version of `round()` (modified from [Andrew Landgraf's blog](http://andrewlandgraf.com/2012/06/15/rounding-in-r/){target=\"_blank\"}). Put it in a hidden code block at the top of your script, with a clear warning that this is changing the way `round()` normally works. You don't need to understand how this function works, just how to use it.\n\nwhen you run this code, a new section will appear in the environment pane labelled \"Functions\". In addition to using functions from packages, you can also make your own. It's not something we are going to go into detail on in this course, but it's useful to know the functionality exists.\n\n```{r}\n#!!!!!! redefining round so 5s round up !!!!!! \nround <- function(x, digits = 0) {\n  posneg = sign(x)\n  z = abs(x)*10^digits\n  z = z + 0.5 + sqrt(.Machine$double.eps)\n  z = trunc(z)\n  z = z/10^digits\n  z*posneg\n}\n```\n\nNow `round()` should work as you'd expect.\n\n```{r}\nround(0.5)\nround(1.5)\n```\n\nJust remove your version if you want R to go back to the original method. Remember that you have to define the new round method in any script that uses it, and run the definition code before you use it interactively. You can check your Environment pane to see whether `round` is listed under \"Functions\".\n\n```{r}\n# remove new round() method\nrm(round)\n```\n\n### Missing values {#sec-missing-values}\n\nIf you have control over your data, it is always best to keep missing values as empty cells rather than denoting missingness with a word or implausible number. If you used \"missing\" rather than leaving the cell empty, the entire variable would be read as character data, which means you wouldn't be able to perform mathematical operations like calculating the mean. If you use an implausible number (0 or 999 are common), then you risk these values being included in any calculations as real numbers.\n\nHowever, we often don't have control over how the data come to us, so let's run through how to fix this.\n\n#### Bad missing values\n\nWhat if the coach hadn't returned the data on the sprinter's bunched starting block position velocity (entered as 0), and hadn't yet timed the sprinter's medium starting block position velocity for 2023, so someone entered it as \"missing\"? We're going to show you two functions that you can use to recode or change values, `ifelse()` and `case_when()`. `ifelse()` is from Base R and can be slightly more intuitive to use initially. `case_when()` is from the <pkg>dplyr</pkg> and allows you to specify multiple criteria, although is slightly more difficult to use so it's good to be aware of both.\n\nFirst, we're going to recode the data to add in the missing values\n\nFor the bunched starting block position data, we can use `ifelse()` to set the value of velocity to 0 if the year is 2023 and position is \"bunched\", otherwise use the value from the velocity column (i.e., don't change).\n\n```{r}\nmissing_bad <- velocity4 %>%\n  mutate(velocity = ifelse(\n    test = year == 2023 & position == \"bunched\", \n    yes = 0, # value if above conditions are met\n    no = velocity # value if above conditions are not met\n  ))\n```\n\nAlternatively, we can use `case_when()` to convert the velocities for 2023 to `0`. The last line of `TRUE ~ velocity` means that the default value is retrieved from the velocity column, if none of the previous criteria applied.\n\n```{r}\nmissing_bad <- velocity4 %>%\n  mutate(velocity = case_when(\n    # set to 0 when year is 2023 and position is bunched\n    year == 2023 & position == \"bunched\" ~ 0, \n    # otherwise, set to the value in the velocity column\n    TRUE ~ velocity   \n  ))\n```\n\n`r hide(\"Using case_when() for multiple criteria\")`\n\nThe `case_when()` function allows allows you to set multiple criteria, although we're only using one non-default criterion here. It can be very useful, but takes a little practice.\n\nThe example below creates a label for each row. Notice how the label for the first row is \"x < 2\", even though this row also fits the second criterion \"y < 4\". This is because `case_when()` applies the first match to each row, even if other criteria in the function also match that row.\n\n```{r}\ndata <- tibble(\n  x = 1:5,\n  y = 1:5\n)\n\ndata %>%\n  mutate(label = case_when(\n    x < 2           ~ \"x < 2\",\n    y < 4           ~ \"y < 4\",\n    x == 5 & y == 5 ~ \"both 5\",\n    TRUE            ~ \"default\"\n  ))\n```\n\n`r unhide()`\n\n\nFor the medium starting block position, we need to recode these values as \"missing\". Since this is character data, and velocities are numeric data, the result will be `r glossary(\"coercion\", \"coerced\")` to a character.\n\n```{r}\n# set velocity values to \"missing\" for medium starting block position 2023 rows\nmissing_bad <- missing_bad %>%\n  mutate(velocity = ifelse(year == 2023 & position == \"medium\", \n                        \"missing\", \n                        velocity))\n\n# check structure of data, velocity now character\nstr(missing_bad)\n```\n\nIf we're using `case_when()`, first we need to convert the velocity column to a character, as this function is a little pickier and won't let you combine `r glossary(\"data type\", \"data types\")`, since this almost always means that you're making a mistake.\n\n```{r}\n# set velocity values to \"missing\" for medium starting block position 2023 rows\nmissing_bad <- missing_bad %>%\n  mutate(velocity = as.character(velocity),\n         velocity = case_when(year == 2023 & position == \"medium\" ~ \"missing\", \n                           TRUE ~ velocity))\n```\n\nNow, if you try to compute the mean velocity, you will get an error message and the result will be `NA`.\n\n```{r eval = TRUE, error=TRUE}\n# try to compute mean velocity\nmissing_bad %>%\n  summarise(mean_velocity = mean(velocity))\n```\n\n#### Convert missing values to NA\n\nTo set the missing values to NA, you could use either `ifelse()` or `case_when()`. Because the `velocity` column was converted to character, we also need to transform this back to numeric.\n\n```{r}\nmissing_data <- missing_bad %>%\n  mutate(\n    # set \"0\" values to NA using ifelse\n    velocity = ifelse(velocity == 0, NA, velocity),\n    # set \"missing\" values to NA using case_when\n    velocity = case_when(velocity == \"missing\" ~ NA_character_,\n                      TRUE ~ velocity),\n    # convert to numeric\n    velocity = as.numeric(velocity)\n  )\n```\n\nBecause `case_when()` is so picky about character types, you need to specify which type of NA you're using (there is a specific NA for each data type). \n\nTechnically, `NA` has a `r glossary(\"logical\")` data type, so functions that aren't as picky about combining data types will `r glossary(\"coercion\", \"coerce\")` this to the NA version for the most compatible data type.\n\nNow, if we try to calculate the mean velocity, we get missing values for any summary value that used one of the bunched or medium starting block position 2023 velocity values.\n\n```{r error=TRUE}\nmissing_data %>%\n  group_by(position) %>%\n  summarise(\n    mean_velocity = mean(velocity),\n    min_velocity = min(velocity),\n    max_velocity = max(velocity),\n    .groups = \"drop\")\n```\n\n#### Ignore missing values\n\nThis is because `NA` basically means \"I don't know\", and the sum of 100 and \"I don't know\" is \"I don't know\", not 100. However, when you're calculating means, you often want to just ignore missing values. Set `na.rm = TRUE` in the summary function to remove missing values before calculating.\n\n```{r}\nmissing_data %>%\n  group_by(position) %>%\n  summarise(\n    mean_velocity = mean(velocity, na.rm = TRUE),\n    min_velocity = min(velocity, na.rm = TRUE),\n    max_velocity = max(velocity, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n```\n\n#### Count missing values\n\nIf you want to find out how many missing or non-missing values there are in a column, use the `is.na()` function to get a `r glossary(\"logical\")` vector of whether or not each value is missing, and use `sum()` to count how many values are TRUE or `mean()` to calculate the proportion of TRUE values.\n\n```{r}\nmissing_data %>%\n  group_by(year, angle) %>%\n  summarise(\n    n_valid = sum(!is.na(velocity)),\n    n_missing = sum(is.na(velocity)),\n    prop_missing = mean(is.na(velocity)),\n    .groups = \"drop\"\n  )\n```\n\n#### Omit missing values\n\nYou may also want to remove rows that have missing values and only work from complete datasets. `drop_na()` will remove any row that has a missing observation. You can use `drop_na()` on the entire dataset which will remove any row that has *any* missing value, or you can specify to only remove rows that are missing a specific value.\n\n```{r}\n# remove any rows with any missing values\ncomplete_data <- missing_data %>%\n  drop_na()\n\n# remove any rows that are missing a value for velocity\ncomplete_velocity <- missing_data %>%\n  drop_na(velocity)\n\n```\n\nMissing data can be quite difficult to deal with depending on how it is represented. As always, no amount of coding expertise can make up for not understanding the structure and idiosyncrasies of your data. \n\n## Exercises {#sec-together-wrangle}\n\nLet's try some exercises using a dataset you already encountered in @sec-viz so that you can see how much more you're able to do with the data now.\n\n* Save your current Markdown, close it, and open a new Rmd named \"function_data_mad_skillz\".\n* In the set-up code chunk, load the tidyverse, then load the dataset from https://healthteachr.github.io/ads-v2/data/Function_and_PA_data into an object named `function_data`.\n* Use your method of choice to review the dataset and familiarise yourself with its structure.\n\n```{r webex.hide = TRUE}\nlibrary(tidyverse)\nfunction_data <- read_csv(\"https://healthteachr.github.io/ads-v2/data/Function_and_PA_data.csv\")\n\n```\n\n### Creating new categories\n\nParticipants with musculoskeletal conditions affecting the joints, bones, or muscles were hospitalised in the last year and participants with no musculoskeletal conditions were not hospitalised in the last year. \n\n* Create a new column named `hospitalised` that lists whether the participant was admitted to hospital in the last year.\n* Then, calculate the average quality-of-life (CASP19) scores for participants who had and had not been hospitalised in the last year, and visualise the quality-of-life scores for each group in whatever way you think best.\n\n` r hide(\"Hint\")`\nTo add the hospitalised column you can either use `case_when()` and specify multiple criteria (e.g., if the participant's condition affects the joints, bones, or muscles, hospitalised, if the participant's condition type is \"None\", not hospitalised), or you could use `ifelse()` and set the `test` to participants who were hospitalised and return `not hospitalised` for all others.\n` r unhide()`\n\n```{r webex.hide = TRUE}\n# case_when() method\nfunction_data <- function_data %>%\n  mutate(hospitalised = case_when(condition_type %in% c(\"Joints\", \"Bones\", \"Muscles\") ~ \"hospitalised\",\n                             condition_type == \"None\" ~ \"not hospitalised\"))\n\n# ifelse() method\n\nfunction_data <- function_data %>%\n  mutate(hospitalised = ifelse(test = condition_type %in% c(\"Joints\", \"Bones\", \"Muscles\"),\n                           yes = \"hospitalised\",\n                           no = \"not hospitalised\"))\n\n# mean quality-of-life scores\nfunction_data %>%\n  group_by(hospitalised) %>%\n  summarise(mean_QoL = mean(CASP19))\n\n# possible visualisation \n\nggplot(function_data, aes(x = CASP19, fill = hospitalised)) +\n  geom_histogram(binwidth = 1, show.legend = FALSE, colour = \"black\") +\n  facet_wrap(~hospitalised) +\n  labs(title = \"Quality-of-life scores by hospital admission\")\n```\n\n### Filter by calculated score\n\nFirst, calculate the average gait speed in m/s and store this in an object named `mean_speed`. This should be a single value rather than a table.\n\n`r hide(\"Hint\")`\nThere are multiple ways to achieve this. You could create the table and then pull out the single value, or just calculate the single value.\n`r unhide()`\n\n```{r webex.hide = TRUE}\n\n# method 1 - tidyverse\nmean_speed <- function_data %>%\n  summarise(mean_speed = mean(gaitspeed)) %>%\n  pull(mean_speed)\n\n# method 2 - base R\nmean_speed <- mean(function_data$gaitspeed)\n\n```\n\nNow create a dataset named `fast_speed` that just contains data from participants whose gait speed was above the sample's average.\n\n```{r webex.hide = TRUE}\nfast_speed <- function_data %>%\n  filter(gaitspeed > mean_speed)\n```\n\nCreate a visualisation that shows how many participants had a gait speed above the sample average for each condition type.\n\n```{r webex.hide = TRUE}\nfast_speed %>%\n  ggplot(aes(x = condition_type)) +\n  geom_bar()\n```\n\n### Multiple critera\n\nNow, add a column to `function_data` named `follow_up` that flags whether a participant should be followed up with a health check. The hospital is short-staffed so only participants that meet all three of the following criteria should be followed-up:\n\n* Their gait speed should be below the average **for all participants**\n* Their step count should be below the average **for their musculoskeletal disease**\n* Their quality-of-life score should be less than 30. \n\nThis is quite complicated and there are multiple ways to achieve the desired outcome. Some approaches may need other functions that were covered in previous chapters and you may need to create intermediate objects.\n\nCall the final object `follow_data` and keep only the participant ID, condition type, hospital admission, and follow up columns. \n\n```{r webex.hide = TRUE}\n\n# this is one possible solution, there are many other valid approaches \n\n# calculate mean gait speed across all participants\nmean_speed <- mean(function_data$gaitspeed)\n\n# calculate mean steps for each type of musculoskeletal disease\nfollow_data <- function_data %>%\n  group_by(musculoskeletal) %>%\n  summarise(mean_steps = mean(steps)) %>%\n#then join it to the function data  \n  left_join(function_data, by = \"musculoskeletal\") %>%\n# then add on the column\n  mutate(follow_up = case_when(gaitspeed < mean_speed & \n                               steps < mean_steps & \n                               CASP19 < 30 ~ \"yes\",\n                               TRUE ~ \"no\")) %>%\n  select(id, condition_type, hospitalised, follow_up)\n```\n\nFor all of the above, write code that stores the answer as a single value, so that you could easily use it in inline coding.\n\nHow many participants need to be followed up:\n\n* In total? `r fitb(\"17\")`\n* From participants with a condition affecting the bones? `r fitb(\"4\")`\n* From participants who were hospitalised in the last year `r fitb(\"15\")`\n* From participants who were not hospitalised in the last year `r fitb(\"2\")`\n\n`r hide(\"Hint\")`\n`group_by %>% count() %>% filter() %>% pull()\n`r unhide()`\n\nWhich condition type has the largest number of participants needing follow-up health checks? `r fitb(\"Joints\")`\n\n`r hide(\"Hint\")`\nAs above but add in an `ungroup()` and `slice_max()` along the way. \n`r unhide()`\n\n```{r webex.hide = TRUE}\n# in total\nfollow_data %>%\n  group_by(follow_up) %>%\n  count()%>%\n  filter(follow_up == \"yes\") %>%\n  pull(n)\n\n# with a condition affecting the bones\nfollow_data %>%\n  group_by(follow_up, condition_type) %>%\n  count() %>%\n  filter(condition_type == \"Bones\",\n         follow_up == \"yes\") %>%\n  pull(n)\n\n# who were hospitalised in the last year\nfollow_data %>%\n  group_by(follow_up, hospitalised) %>%\n  count() %>%\n  filter(hospitalised == \"hospitalised\",\n         follow_up == \"yes\") %>%\n  pull(n)\n\n# who were not hospitalised in the last year\nfollow_data %>%\n  group_by(follow_up, hospitalised) %>%\n  count() %>%\n  filter(hospitalised == \"not hospitalised\",\n         follow_up == \"yes\") %>%\n  pull(n)\n\n# most follow-ups needed\nfollow_data %>%\n  group_by(follow_up, condition_type) %>%\n  count() %>%\n  ungroup() %>%\n  filter(follow_up == \"yes\") %>%\n  slice_max(n = 1, order_by = n) %>%\n  pull(condition_type)\n\n```\n\n### Original insight\n\nIn preparation for the final summative assessment, explore the data to provide one original insight of your own.\n\n### Report\n\nCompile all the above into a visually appealing reproducible report that could be used to target participants for extra care. Use inline coding to report any numbers in the text. Once you're finished, post your Rmd and knitted html document on teams so that other learners can see your approach.\n\n\n## Glossary {#sec-glossary-wrangle}\n\n```{r, echo = FALSE, results='asis'}\nglossary_table(as_kable = FALSE) |> \n  kableExtra::kable(row.names = FALSE, escape = FALSE) |>\n  unclass() |> cat()\n```\n\n## Further resources {#sec-resources-wrangle}\n\n* [Data transformation cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf)\n* [Chapter 5: Data Transformation ](http://r4ds.had.co.nz/transform.html) in *R for Data Science*\n* [Chapter 19: Functions](https://r4ds.had.co.nz/functions.html) in *R for Data Science*\n* [Introduction to stringr](https://stringr.tidyverse.org/articles/stringr.html)\n\n\n\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"kable","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"wrap","code-link":true,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["include/healthteachr.css","include/webex.css","include/style.css"],"highlight-style":"a11y","include-after-body":["include/webex.js","include/script.js"],"output-file":"09-wrangle.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","bibliography":["include/book.bib","include/packages.bib"],"csl":"include/apa.csl","theme":{"light":["flatly","include/light.scss"],"dark":["darkly","include/dark.scss"]},"number-depth":3,"code-copy":"hover"},"extensions":{"book":{"multiFile":true}}}}}